# 자바의 정석

---

## 목차 

### Chapter.01  - 자바를 시작하기 전에

### Chapter.02 - 변수(Variable)

Chapter.03

Chapter.04

Chapter.05

Chapter.06

Chapter.07

Chapter.08

Chapter.09

Chapter.10

Chapter.11

Chapter.12

Chapter.13

Chapter.14

Chapter.15

Chapter.16





---

### Chapter.01  - 자바를 시작하기 전에

#### 1.자바(Java Programming Language) 

002~004 p

#### 2.자바개발환경 구축하기

006~007 p

---

#### 3.자바로 프로그램작성하기

#### 3.1 Hello.java

자바로 프로그램을 개발하려면 JDK이외에도 편집기가 필요하다. 
메모장과 같은 간단한 편집기도 있지만, 처음 자바를 배우는 사람들에게는
이클립스(eclipse)나 인텔리제이(IntelliJ)와 가이 다양하고 편리한 기능을 겸비한
고급 개발도구를 사용하는 것이 좋다. 이클립스에 비해 기능은 떨어지지만
가볍고 간단한 편집기로 에딧플러스(editplus)라는 것도 있다.

예제 1-1

```java
class Hello {
    public static void main(Stirng[] args) {
        System.out.println("Hello, world."); //화면에 글자를 출력한다.
    }
}
```

이 예제는 화면에 "Hello,world."를 출력하는 아주 간단한 프로그램이다.
이 예제를 통해서 화면에 글자를 출력하려면 어떻게 해야 하는지 쉽게 알 수 있을 것이다. 

예제 1-1을 편집기나editplus를 이용해서 작성한 다음 'Hello.java'로 저장하자.
이 때 클래스의 이름 'Hello'가 대소문자까지 정확히 같아야 한다.
이 예제를 실행하려면, 먼저 자바컴파일러(javac.exe)를 사용해서
소스파일 (Hello.java)로부터 클래스파일(Hello.class)을 생성해야한다.
그 다음에 자바 인터프리터(java.exe)로 실행한다.

Hello.java작성 → javac.exe(컴파일) → Hello.class 생성 → java.exe(실행) → '"Hello.world." 출력

자바에서 모든 코드는 반드시 클래스 안에 존재해야 하며,
서로 관련된 코드들은 그룹으로 나누어 별도의 클래스를 구성하게 된다.
그리고 이 클래스들이 모여 하나의 Java 애플리케이션을 이룬다.
클래스를 작성하는 방법은 간단하다.
키워드 'class'다음에 클래스의 이름을 적고,
클래스의 시작과 끝을 의미하는 괄호{} 안에 원하는 코드를 넣으면 된다.      

```java
class 클래스이름 {
    /*
     주석을 제외한 모든 코드는 클래스의 블럭{} 내에 작성해야 한다.
    */
}
```

|참고| 나중에 배우게 될 package문과 import문은 예외적으로 클래스의 밖에 작성한다.

아래 코드의 'public static void main(String[] args)'는 main메서드의 선언부인데,
프로그램을 실행할 때 'java.exe'에 의해 호출될 수 있도록 미리 약속된 부분이므로
항상 똑같이 적어주어야 한다.

|참고| '[]'은 배열을 의미하는 기호로 배열의 타입(type) 또는 배열의 이름 옆에 붙일 수 있다.                    'String[] args'는 String타입의 배열 args를 선언한 것이며, 'String args[]'와 같이 쓸 수도 있다.
이 둘은 같은 의미이므로 차이가 없다. 

```java
class 클래스이름 {
    public static void main(String[] args) //main 메서드의 선언부
        {
            실행될 문장들을 적는다.
        }
    
}
```

main메서드의 선언부 다음에 나오는 괄호{}는 메서드의 시작과 끝을 의미하며,
이 괄호 사이에 작업할 내용을 작성해 넣으면 된다.
 java어플리케이션은 main메서드의 호출로 시작해서
main메서드의 첫 문장부터 마지막 문장까지 수행을 마치면 종료된다.

모든 클래스가 main메서드를 가지고 있어야 하는것은 아니지만,
하나의 Java 애플리 케이션에는 main메서드를 포함한 클래스가 반드시 하나는 있어야 한다.
main메서드는 Java애플리케이션의 시작점이므로 main메서드 없이는 java애플리케이션은
실행될 수 없기 떄문이다. 작성된 Java애플리케이션을 실행할 떄는
'java.exe'다음에 main메서드를 포함하 클래스의 이름을 적어줘야 한다.

하나의 소스파일에 하나의 클래스만을 정의하는 것이 보통이지만, 
하나의 소스파일에 둘 이상의 캘르스를 정의하는 것도 가능하다.
이 때 주의해야할 점은 '소스파일의 이름은 public class의 이름과 일치해야 한다.'는 것이다.
만일 소스파일 내에 public class가 없다면, 소스파일의 이름은
소스파일 내의 어떤 클래스의 이름으로 해도 상관없다.

소스파일(.java)와 달리 클래스파일(.class)은 클래스마다 하나씩 만들어지므로
소스에 public이 없이 두 개의 class 가 선언되어 있으면 컴파일시 두 개의 클래스파일이 생성된다.

---

#### 3.2 자주 발생하는 에러와 해결방법

자바로 프로그래밍을 배워나가면서 많은 수의 크고 작은 에러들을 접하게 될 것이다.
대부분의 에러는 작은 실수에서 비롯된 것들이며, 곧 익숙해져서 쉽게 대응할 수 있게 되지만
처음 배울 떄는 작은 실수 하나 떄문에 많은 시간을 허비하곤 한다. 

그래서 자주 발생하는 기본적인 에러와 해결방법을 간단히 정리하였다.
에러가 발생하였을 때 참고하고, 그외의 에러는 에러메시지의 일부를 검색해서 찾아보면
해결책을 얻는데 도움이 될 것이다.

- cannot find sysbol 또는 cannot resolve symbol

지정된 변수나 메서드를 찾을 수 없다는 뜻으로 선언되지 않는 변수나 메서드를 사용하거나,
변수 또는 메서드의 이름을 잘못 사용한 경우에 발생한다.
자바에서는 대소문자 구분을 하기 떄문에 철자 뿐 만아니라
대소문자의 일치여부도 꼼꼼하게 확인해야한다.

- ';' expected

세미콜론 ';'이 필요한 곳에 없다는 뜻이다. 자바의 모든 문장의 끝에는 ';'을 붙여주어야 하는데
가끔 이를 잊고 실수하기 쉽다.

- Exception in thread "main" java.lang.NoSuchMethodError: main

'main 메서드를 찾을 수 없다.'는 뜻인데 실제로 클래스 내에 main메서드가 존재하지 않거나
메서드의 선언부 'public static void main(String[] args)'에 오타가 존재하는 경우에 발생한다.
이 에러의 해결방법은 main메서드가 클래스에 정의되어 있는지 확인하고,
정의되어 있다면 main메서드의 선언부에 오타가 없는지 확인한다.
자바는 대소문자를 구별하므로 대소문자의 일치여부까지 정확히 확인해야한다.

|참고| args는 매개변수의 이름이므로 args 대신 argv나 arg와 같이 다른 이름을 사용할 수 있다.

- Exception in thread "main" java.lang.NoClassDefFoundError: Hello

'Hello라는 클래스를 찾을 수 없다.'는 뜻이다. 클래스 'Hello'의 철자,
특히 대소문자를 확인해보고 이상이 없으면 클래스파일(.class)이 생성되었는지 확인한다. 
클래스파일이 존재하는데도 동일한 메시지가 반복해서 나타난다면 
클래스패스(classpath)의 설정이 바르게 되었는지 다시 확인해보자.

-  illegal start of expression

직역하면 문장(또는 수식, expression)의 앞부분이 문법에 맞지 않는다는 의미인데,
 간단히말해서 문장에 문법적 오류가 있다는 뜻이다. 괄호 '(' 나 '{' 를 열고서 닫지 않거나,
 수식이나 if문, for문 등에 문법적 오류가 있을 때 또는 public이나 static과 같은 키워드를  
 잘 못사용하는 경우에도 발생한다. 에러가 발생한 곳이 문법적으로 옳은지 확인하라.

-  class, interface, or enum expected

이 메시지의 의미는 '키워드 class 나 interface 또는 enum이 없다. '이지만,
 보통 괄호 '{' 또는 '}' 의 개수가 일치 하지 않는 경우에 발생한다.
 열린괄호'{'와 닫힌괄호'}'의 개수가 같은지 확인하자.
 마지막으로 한 가지 더 얘기하고 싶은 것은 에러가 발생했을 떄,
 어떻게 해결할 것인가에 대한 방법이다.  아주 간단하고 당연한 내용이라서 다소 실망스럽게
 느껴질지도 모르지만, 막상 실제 에러가 발생했을 떄 아래의 순서대로 처리해보면 
 도움이 될 것이다.

1.에러 메시지를 잘 읽고 해당 부분의 코드를 살펴본다.
  이상이 없으면 해당 코드의 주위(윗줄과 아래 줄)도 함께 살펴본다.

2.그래도 이상이 없으면 에러 메시지는 잊어버리고 기본적인 부분을 재확인한다.
   대부분의 에러는 사소한 것인 경우가 많다.

3.의심이 가는 부분을 주석처리하거나 따로 떼어내서 테스트 한다.

 에러 메시지가 실제 에러와는 관계없는 내용일 때도 있지만, 대부분의 경우
 에러 메시지만 잘 이해해도 문제가 해결되는 경우가 많으므로
 에러 해결을 위해서 제일 먼저 해야 할 일은 에러 메시지를 잘 읽는 것임을 명심하자.

---

#### 3.3 자바프로그램의 실행과정

콘솔에서 아래와 같이 java 애플리케이션을 실행시켰을 때

```
 c:/jdk1.8\work>java Hello
```

내부적인 진행순서는 다음과 같다.

1.프로그램의 실행에 필요한 클래스(.class파일)을 로드한다.

2.클래스파일을 검사한다. (파일형식, 악성코드 체크)

3.지정된 클래스(Hello)에서 main(String[] args)를 호출한다.

main메서드의 첫 줄부터 코드가 실행되기 시작하여 마지막 코드까지 모두 실행되면
프로그램이 종료되고, 프로그램에서 사용했던 자원들은 모두 반환된다.

만일 지정된 클래스에 main메서드가 없다면 다음과 같은 에러 메시지가 나타날 것이다.

```
Exception in thread "main" java.lang.NoSuchMethodError: main
```

---

#### 3.4 주석(comment)

작성하는 프로그램의 크기가 커질수록 프로그램을 이해하고 변경하는 일이 점점 어려워 진다.
심지어는 자신이 작성한 프로그램도 '내가 왜 이렇게 작성했지?' 라는 의문이 들기도 하는데,
남이 작성한 코드를 이해한다는 것은 정말 쉬운 일이 아니다.

이러한 어려움을 덜기 위해 사용하는 것이 바로 주석이다. 주석을 이용해서
프로그램 코드에 대한 설명을 적절히 덧붙여 놓으면 프로그램을 이해하는 데 많은 도움이 된다.
그 외에도 주석은 프로그램의 작성자, 작성일시, 버전과 그에 따른 변경이력 등의 정보를 제공할
목적으로 사용된다. 
주석을 작성하는 방법은 다음과 같이 두 가지 방법이 있다. '/*' 와   '* /' 사이에 주석을 넣는 방법과
앞에 '//'를 붙이는 방법이 있다.

```
범위 주석 /* 와 */사이의 내용은 주석으로 간주된다.
한줄 주석 //부터 라인 끝까지의 내용은 주석으로 간주된다.
```

|참고| 이 주석은 javadoc.exe에 의해서 html문서로 자동 변환되며, 보다 자세한 내용은
인터넷에서 'javadoc'으로 검색하면 찾을 수 있다.

다음은 주석의 몇 가지 사용 예 이다. 

```java
class Hello {
    public static void main(String[] args) { /* 프로그램의 시작 */
        System.out.println("Hello, world.");  //Hello, world를 출력
    }
}
```

컴파일러는 주석을 무시하고 건너뛰기 때문에 위의 코드를 컴파일한 결과와 위 예제를
컴파일한 결과는 정확히 일치한다. 따라서 주석이 많다고 해서 프로그램의 성능이
떨어지는 일은 없으니 안심하고 주석을 적극적으로 활용하자.

|참고| 주석이 너무 많아서 코드를 보는데 오히려 방해가 된다고 생각되는 경우, 
주석의 색깔을 배경색과 유사한 색을 사용해서 잘 안보이게 하면 된다.
그리고 주석을 보고 싶을 떄는 해당 부분을 마우스로 드래깅하면 반전되어 화면에 나타난다.

---

####  3.5 이 책으로 공부하는 방법

014p

---

### Chapter.02 - 변수(Variable)

중요한 프로그래밍 능력 중의 하나가 바로 '값(data)을 잘 다루는 것'이다.
값을 저장하는 공간인 변수를 잘 이해하고 활용하는 것은 그 능력을 얻기 위한 첫 걸음이니
첫 단추를 잘 끼우자.

#### 

####  1.1 변수란? 

수학에서 '변수'를 '변하는 수'라고 정의하지만 프로그래밍언어에서의 변수(variable)란,
값을 저장할 수 있는 메모리상의 공간을 의미한다.
이 공간에 저장된 값은 변경될 수 있기 때문에 '변수'라는 수학용어의 정의와 상통하는 면이 있어서
이렇게 이름붙여졌다.

```
"변수란, 단 하나의 값을 저장할 수 있는 메모리 공간."
```

하나의 변수에 단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기존의 값은 사라진다.

---

#### 1.2 변수의 선언과 초기화

변수를 사용하려면 먼저 변수를 선언해야하는데, 변수의 선언방법은 다음과 같다.

```java
int age;  //age 라는 이름의 변수를 선언
```

'변수타입'은 변수에 저장될 값이 어떤 '타입(type)'인지를 지정하는 것이다.
저장하고자 하는 값의 종류에 맞게 변수의 타입을 선택해서 적어주면 된다.
C언어는 정수형, 실수형, 문자형 등 다양한 타입을 제공한다.

'변수이름'은 말 그대로 변수에 붙인 이름이다. 변수는 '값을 저장할 수 있는 메모리 공간' 이므로
변수의 이름은 메모리 공간에 이름을 붙여주는 것이다. 그래야 그 이름을 이용해서 저장공간(변수)
에 값을 저장하고, 저장된 값을 읽어오기도 할 수 있는 것이다. 
당연한 얘기지만 같은 이름의 변수가 여러 개 존재해서는 안된다.
서로 구별될 수 있어야하기 때문이다.
변수를 선언하면, 메모리의 빈 공간에 '변수타입'에 알맞은 크기의 저장공간이 확보되고,
앞으로 이 저장공간은 '변수이름'을 통해 사용할 수 있게 된다.

위의 문장은 변수'age'를 선언한다. 이 변수는 '나이'를 저장하기 위한 것이고,
나이는 '정수(integer)'이므로 변수의 타입을 'int'로 지정하였다.
'타입(type)"에 대해서는 곧 자세히 다룰 것이므로 지금은 정수를 저장하려면 변수의 타입을
'int'로 한다는 정도만 알아두자.

#### 변수의 초기화

변수를 선언한 이후부터는 변수를 사용할 수 있으나, 그 전에는 반드시 변수를
'초기화(initialization)'해야 한다. 메모리는 여러 프로그램이 공유하는 자원이므로
전에 다른 프로그램에 의해 저장된 '알 수 없는 값(쓰레기값, garbage value)' 이 
남아있을 수 있기 떄문이다.

변수에 값을 저장할 떄는 대입 연산자'='를 이용한다. 수학에서는 양변의 값이 같다는 뜻이지만,
C언어에서는 오른쪽의 값을 왼쪽(변수)에 저장하라는 뜻이다. 그래서 대입연산자의 왼쪽에는
반드시 변수가 와야 한다.

```java
int age = 25; //변수 age를 선언하고 25로 초기화 한다.
```

양쪽의 코드는 서로 같은 의미의 다른 코드이다. 변수는 한 줄에 하나씩 선언하는 것이
보통이지만, 타입이 같은 경우 콤미 ','를 구분자로 여러 변수를 한줄에 선언하기도 한다.

```java
int a;                 int a,b;
int b;             	   int x = 0, y = 0;
int x = 0;
inx y = 0;
```

변수의 종류에 따라 변수의 초기화를 생략할 수 있는 경우도 있지만, 
변수는 사용되기전에 적절한 값으로  초기화 하는 것이 좋다.

|참고|지역변수는 사용되기 전에 초기화를 반드시 해야 하지만 클래스변수와 인스턴스 변수는
초기화를 생략할 수 있다.

```
"변수의 초기화란, 변수를 사용하기 전에 처음으로 값을 저장하는 것"
```

지금까지 변수를 선언하고 값을 저장하는 방법을 알아봤으니, 
이제 예제를 통해 변수에 저장된 값을 어떻게 읽어오는지 알아보자.

```java
class VarEx1 {
    public static void mian(String[] args) {
        int year = 0;
        int age = 14;
        
        System.out.println(year);
        System.out.println(age);
        
        year = age + 2000; //변수 age의 값에 2000을 더해서 변수 year에 저장
        age = age + 1;     //변수 age에 저장된 값을 1 증가시킨다.
        
        System.out.println(year);
        System.out.println(age);
    }
}
```

위 코드의 실행결과는 

0
14
2014
15

두 개의 변수 age와 year를 선언한 다음, 값을 저장하고 출력하는 간단한 예제이다.
먼저 변수의 선언부분을 보면, 변수 year와 age를 각각 0과 14로 초기화 하였다.

앞에서 살펴본 것처럼 화면에 글자를 출력하려면 println()을 사용한다.

```java
System.out.println(year);  //변수 year의 값을 화면에 출력
System.out.println(age);   //변수 age의 값을 화면에 출력
```

그 다음의 문장은 변수 age에 저장된 값에 2000을 더한 다음,
그 결과를 변수 year에 저장하라는 뜻이다.

```java
year = age + 2000;
```

이 문장이 처리되는 과정을 단계별로 살펴보면 다음과 같다.

year = age + 2000; 

   →     year = 14 + 2000;     //변수 age에 저장된 값(14)을 읽어와서 식에 사용

   →     year = 2014;             // 변수 year에 2014를 저장한다.

위의 과정에서 알 수 있듯이 변수에 저장된 값을 사용하려면, 그저 변수의 이름만 적어주면 된다.
그리고 변수에 값을 저장하는 '대입연산(=)'은 우변의 모든 계산이 끝난 후에 제일 마지막에 수행된다.

다음의 코드는 변수 age에 저장된 값을 1증가 시키는데, 변수의 값을 읽어다 1을 더한다음
다시 변수 age에 저장하라는 뜻이다.

```java
age = age + 1;
```

위 문장이 처리되는 과정을 단계별로 살펴보면 다음과 같다.

```java
age = age + 1;
=> age = 14 + 1; //변수 age에 저장된 값을 읽어온다.
=> age = 15;     //변수 age에 15를 저장한다.
```

#### 두 변수의 값 교환하기

다음과 같이 변수 x,y가 있을 때 , 두 변수에 담긴 값을 서로 바꾸는 방법

```java
int x = 10;
int y = 20;
```

단순하게 변수 x의 값을 y에 저장하고, y의 값을 x에 저장하면 될 것 가지만 그렇게
해서는 원하는 결과를 얻을 수 없다,

1. 변수 y에 저장된 값을 변수 x에 저장

   x = y;

2. 변수 x에 저장된 값을 변수 y에 저장

   y = x;

첫 번째 단계에서 y의 값을 x에 저장할 때, 이미 x의 값이 없어졌기 때문에
x의 값을 y에 저장해도 소용없는 것이다.
다음과 같이 변수를 하나 더 선언해서 x의 값을 위한 임시 저장소로 사용하면 된다.

```java
int x = 10;
int y = 20;
int tmp; // x값을 임시로 저장할 변수를 선언
```

그 다음에 아래와 같은 순서로 값을 옮기면 된다.

두 변수의 값을 교환하는 것은 마치 두 컵에 담긴 내용물을 바꾸려면 컵이 하나 더 필요한 것과 같다.

```java
class VarEx2 {
    public static void main(String[] args) {
        int x = 10, y = 20;
        int tmp = 0;
        
        System.out.println("x:" + x + " y: " + y);
        
        tmp = x;
        x = y;
        y = tmp;
        
        System.out.println("x:" + x "y:" + y);
    }
}
```

실행결과 

x: 10  y:20
x:20   y:20

덧셈연산자 '+'는 두 값을 더하기도 하지만, 이처럼 문자열과 숫자를 하나로 결합하기도 한다.
문자열은 큰따옴표""로 묶은 연속된 문자를 말한다.

#### 1.3 변수의 명명규칙

'변수의 이름'처럼 프로그래밍에서 사용하는 모든 이름을 '식별자(identifier)'라고 하며,
식별자는 같은 영역 내에서 서로 구분(식별)될 수 있어야한다. 그리고 식별자를 만들 때는 다음과 같은 규칙을 지켜야 한다.

```java
1.대소문자가 구분되며 길이에 제한이 없다.
    - True와 true 는 서로 다른 것으로 간주된다.
2.예약어를 사용해서는 안 된다.
    - true는 예약어라서 사용할 수 없지만, True는 가능하다.
3.숫자로 시작해서는 안 된다.
    - top10은 허용하지만, 7up은 허용되지 않는다.
4.특수문자는 '_'와 '$'만을 허용한다.
    - $harp은 허용되지만, S#arp은 허용되지 않는다
```

예약어는 키워드(keyword) 또는 '리져브드 워드(reserved word)'라고 하는데, 
프로그래밍언어의 구문에 사용되는 단어를 뜻한다. 
그래서 예약어는 클래스 변수, 메서드의 이름 (identifier)으로 사용할 수 없다.

java의 예약어는 인터넷 참조

그 외에 필수적인 것은 아니지만 자바 프로그래머들에게 권장하는 규칙들은 다음과 같다.

```java
1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
    - 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
    - lastlndexOf, StringBuffer
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 '_'로 구분한다.
    - PI . MAX_NUMBER
```

위의 규칙들은 반드시 지켜야 하는 것은 아니지만, 코드를 보다 이해하기 쉽게 하기 위한
자바 개발자들 사이의 암묵적인 약속이다. 이 규칙을 따르지 않는다고 해서 문제가 되는것은 아니지만 가능하면 지키도록 노력하자. 만일 특별한 방식으로 식별자를 작성해야 한다면
미리 규칙(coding convention)을 정해놓고 프로그램 전체에 일관되게 적용하는 것이 필요하다.

|참고| 자바에서는 모든 이름에 유니코드에 포함된 문자들을 사용할 수 있지만,
          적어도 클래스이름은 ASCII코드 (영문자)로 하는것이 좋다.
          유니코드를 인식하지 못하는 운영체제(OS)도 있기 때문이다.

변수의 이름은 짧을수록 좋지만, 약간 길더라도 용도를 알기 쉽게 '의미있는 이름'으로 하는것이
바람직하다. 변수의 선언문에 주석으로 변수에 대한 정보를 주는 것도 좋은 생각이다.

```java
int curPos = 0;   //현재 위치 (current position)
int lastPos = -1; //마지막 위치(last position)
```

---

### 2. 변수의 타입

우리가 주로 사용하는 값(data)의 종류(type)는 크게 '문자로 숫자'로 나눌 수 있으며,
숫자는 다시 '정수와 실수'로 나눌 수 있다.

이러한 값(data)의 종류(type)에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이
자료형(data type)이다.
자료형에는 문자형(char), 정수형(byte,short,int,long), 실수형(float,double)등이 있으며,
변수를 선언할 때는 저장하려는 값의 특성을 고려하여 가장 알맞은 자료형을 변수의 타입으로
선택하면 된다.

#### 기본형과 참조형

자료형은 크게 '기본형'과 '참조형' 두 가지로 나눌 수 있는데, 기본형 변수는 실제 값(data)을 저장
하는 반면, 참조형 변수는 어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다.

자바는 C언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두
기본형 변수이다. 

|참고|메모리에는 1byte단위로 일련번호가 붙어있는데, 이번호를 메모리 주소
또는 간단히 '주소' 라고 한다. 객체의 주소는 객체가 저장된 메모리 주소를 뜻한다.

```java
기본형(primitive type)
    - 논리형(boolean),문자형(char),정수형(byte,short,int,long),실수형(float,double)
      계산을 위한 실제 값을 저장한다. 모두 8개
참조형(reference type)
    - 객체의 주소를 저장한다. 8개의 기본형을 제외한 나머지 타입.
```

참조형 변수(또는 참조변수)를 선언할 떄는 변수의 타입으로 클래스의 이름을 사용하므로
클래스의 이름이 참조변수의 타입이 된다. 그래서 새로운 클래스를 작성한다는 것은 
새로운 참조형을 추가하는 셈이다.
다음은 참조변수를 선언하는 방법이다. 기본형 변수와 같이 변수이름 앞에 타입을 적어주는데
참조변수의 타입은 클래스의 이름이다.

```
클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조 변수이다.
```

다음은 Data클래스 타입의 참조변수 today를 선언한 것이다. 참조변수는 null 또는
객체의 주소를 값으로 갖으며 참조변수의 초기화는 다음과 같이 한다.

```java
Data today = new Date(); //Data객체를 생성해서, 그 주소를 today에 저장
```

객체를 생성하는 연산자 new의 결과는 생성된 객체의 주소이다.
이 주소가 대입연산자'='에 의해서 참조변수 today에 저장되는 것이다. 
이제 참조변수 today를 통해 생성된 객체를 사용할 수 있게 된다.

```java
자료형(data type)과 타입(type)의 차이
    기본형은 저장할 값(data)의 종류에 따라 구분되므로 기본형의 종류를 얘기할 떄는
    '자료형(data type)'이라는 용어를 씁니다. 그러나 참조형은 항상 
    '객체의 주소(4 byte 정수)' 를 저장하므로 값(data)이 아닌, 객체의 종류에 의해
    구분되므로 참조형 변수의 종류를 구분할 때는 '타입(type)'이 '자료형(data type)'을
    포함하는 보다 넓은 의미의 용어이므로 구분하지 않아도 된다.
```

---

### 2.1 기본형(primitive type)

기본형에는 모두 8개의 타입(자료형)이 있으며, 크게 논리형 문자형, 정수형, 실수형으로 구분된다.

|  분류  |                             타입                             |
| :----: | :----------------------------------------------------------: |
| 논리형 | boolean<br />true와 false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용된다. |
| 문자형 | char<br />문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다. |
| 정수형 | byte,short,int,long<br />정수를 저장하는데 사용되며, 주로 int가 사용된다. byte는 이진 데이터를 다룰 때 사용되며, short은 C언어와의 호환을 위해서 추가되었다. |
| 실수형 | float,double<br />실수를 저장하는데 사용되며, 주로 double이 사용된다. |



문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 떄문에 정수형과 별반 다르지 않으며,
정수형 또는 실수형과 연산도 가능하다. 반면에 boolean은 다른 기본형과의 연산이 불가능하다.
즉, boolean을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다.

정수는 가장 많이 사용되므로 타입을 4가지나 제공한다. 각 타입마다 저장할 수 있는 값의 범위가 다르므로
저장할 값의 범위에 맞는 타입을 선택하면 되지만, 일반적으로 int를 많이 사용한다.
왜냐하면, int는 CPU가 가장 효율적으로 처리할 수 있는 타입이기 때문이다. 
효율적인 실행보다 메모리를 절약하려면, byte나 short을 선택하자

|참고|

4개의 정수형(byte,short,int,long)중에서 int형이 기본 자료형(default data type) 이며,
실수형(float,double)중에서는 double이 기본 자료형이다

| 종류/크기 |  1byte  | 2byte | 4byte | 8byte  |
| :-------: | :-----: | :---: | :---: | :----: |
|  논리형   | boolean |       |       |        |
|  문자형   |         | char  |       |        |
|  정수형   |  byte   | short |  int  |  long  |
|  실수형   |         |       | float | double |





기본 자료형의 종류와 크기는 반드시 외워야 하며, 아래의 문장들이 도움이 될것이다.

- boolean은 true와 false 두 가지 값만 표현할 수 있으면 되므로 가장 작은 크기인 1 byte.
- char은 자바에서 유니코드(2 byte 문자체계)를 사용하므로 2 byte.
- byte는 크기가 1byte라서 byte.
- int(4 byte)를 기준으로 짧아서 short(2 byte), 길어서 long(8 byte), (short <-> long)
- float는 실수값을 부동 소수점(floationg - point)방식으로 저장하기 때문에 float.
- double은 float보다 두 배의 크기(8 byte)를 갖기 때문에 double.

그리고 각 타입의 변수가 저장할 수 있는 값의 범위는 인터넷 참고

각 자료형이 가질 수 있는 값의 범위를 정확히 외 울 필요는 없고, 정수형(byte, short, int, long)의 경우
'-2 제곱 n-1 ' ~ 2 제곱 n-1 -1 ' (n은 bit수)이라는 정도만 기억하고 있으면 된다.

따라서 int 타입의 변수는 대략 10자리 수 (약 20억, 2,000,000,000)의 값을 저장할 수 있다는 것을 알 수 있다.
7~9자리의 수를 계산할 때는 넉넉하게 long타입 (약 19자리) 으로 변수를 선언하는 것이 좋다. 
연산중에 저장범위를 넘어서게 되면 원하느 않는 값을 결과로 얻게 될 것이기 때문이다.

| 자료형 | 정밀도 | bit  | byte |
| :----: | :----: | :--: | :--: |
| float  | 7자리  |  32  |  4   |
| double | 15자리 |  64  |  8   |

float은 정밀도가 7 자리밖에 되지 않으므로 보다 높은 정밀도가 필요한 경우에는 변수의 타입으로
double을 선택해야한다. 이처럼 실수형에서는 저장 가능한 값의 범위뿐만 아니라 정밀도도 타입 선택의
중요한 기준이 된다.

---

### 2.2 상수와 리터럴(constant & literal)

'상수(constant)'는 변수와 마찬가지로 '값을 저장할 수 있는 공간'이지만, 변수와 달리 한번 값을 저장하면
다른 값으로 변경할 수 없다. 상수를 선언하는 방법은 변수와 동일하며, 단지 변수의 타입 앞에
키워트 'final'을 붙여주기만 하면 된다.

```java
final int MAX_SPEED = 10; //상수 MAX_SPEED를 선언 & 초기화
```

그리고 상수는 반드시 선언과 동시에 초기화해야 하며, 그 후 부터는 상수의 값을 변경하는 것이 허용되지 않는다.

```java
final int MAX_SPEED; // 에러 . 상수는 선언과 동시에 초기화해야함
final int MAX_VALUE = 100;  //ok. 선언과 동시에 초기화했음
MAX_VALUE = 200;       //에러 . 상수의 값은 변경할 수 없음
```

상수의 이름은 모두 대문자로 하는 것이 암묵적인 관례이며, 여러 단어로 이루어져있는 경우 '_'로 구분한다.

|참고|

JDK1.6부터 상수를 선언과 동시에 초기화 하지 않아도 되며, 사용하기 전에만 초기화하면 되도록 바뀌었다.
그래도 상수는 선언과 동시에 초기화하는 습관을 들이는 것이 좋다.

#### 리터럴

원래 12, 123, 3.14, 'A'와 같은 값들이 '상수'인데, 프로그래밍에서는
상수를 '값을 한 번 저장하면 변경할 수 없는 저장공간'으로 정의하였기 때문에 이와 구분하기 위해
상수를 다른 이름으로 불러야만 했다. 그래서 상수 대신 리터럴이라는 용어를 사용한다. 많은 사람들이
리터럴이라는 용어를 어려워하는데, 리터럴은 단지 우리가 기존에 알고 있던'상수'의 다른 이름일 뿐이다.

```java
변수(variable) 하나의 값을 저장하기 위한 공간
상수(constant) 값을 한번만 저장할 수 있는 공간
리터럴(literal) 그 자체로 값을 의미하는 것
int year = 2014;
final int MAX_VALUE = 100;
year은 변수   2014 와 100은 리터럴   MAX_VALUE는 상수
```

#### 상수가 필요한 이유

아마도 이쯤에서  '그냥 리터럴을 직접 쓰면 될 텐데, 굳이 상수가 따로 필요한가?'라는 라는 의문이 들 수 있다.
먼저 다음의 코드를 보자.

```java
int triangleArea = (20 * 10) / 2; //삼각형의 면적을 구하는 공식
int rectangleArea = 20 * 10 ; //사각형의 면적을 구하는 공식
```

위의 코드는 삼각형과 사각형의 면적을 구해서 변수에 저장한다. 이 공식을 모르는사람은 없겠지만,
보자 복잡한 공식이라면 얘기가 달라질 것이다. 게다가 20과 10이 아닌 다른 값을 이용해서
결과를 얻고 싶다면 여러 곳을 수정해야한다. 
그러면 이제 다음의 코드를 보자

```java
final int WIDTH = 20;  // 폭
final int HEIGHT = 10; //높이
int triangleArea = (WIDTH * HEIGHT) / 2; //삼각형의 면적을 구하는 공식
int rectangleArea = WIDTH * HEIGHT ; // //사각형의 면적을 구하는 공식
```

상수를 이용해서 기존의 코드를 변경한 것인데, 이전 코드에 비해 면적을 구하는 공식의 의미가 명확해졌다.
그리고 다른 값으로 계산할 때도 여러 곳을 수정할 필요없이 상수의 초기화만 다른 값으로 해주면 된다.
이처럼 상수는 리터럴에 '의미있는 이름'을 붙여서 코드의 이해와 수정을 쉽게 만든다.

#### 리터럴의 타입과 접미사

변수에 타입이 있는 것처럼 리터럴에도 타입이 있다.
변수의 타입은 저장될 '값의 타입(리터럴의 타입)'에 의해 결정되므로, 만일 리터럴에 타입이 없다면
변수의 타입도 필요없을 것이다.

|  종류  |            리터럴            | 접미사 |
| :----: | :--------------------------: | :----: |
| 논리형 |          false,true          |  없음  |
| 정수형 |   123,0b0101,077,0xFF,100L   |   L    |
| 실수형 | 3.14 , 3.0e8, 1.4f, 0x1.0p-1 |  f, d  |
| 문자형 |        'A', '1', '\n'        |  없음  |
| 문자열 |  "ABC", "123", "A", "true"   |  없음  |

참고로 잘 쓰이지는 않지만 기호 p를 이용해서 실수 리터럴을 16진 지수형태로 표현할 수도 있다. 
p2는 2의 제곱을 의미하며, p의 왼쪽에는 16진수를 적고 오른쪽에는 지수를 10진 정수로 적는다.
p는 대소문자 모두 가능하며, p가 포함된 리터럴은 실수형이다.

#### 타입의 불일치 

리터럴의 타입은 저장될 변수의 타입과 일치하느 것이 보통이지만, 타입이 달라고
저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.

```java
int i = 'A'; //ok. 문자'A'의 유니코드인 65가 변수 i에 저장된다.
long l = 123;//ok. int보다 long타입이 더 범위가 넓다.
double d = 3.14f; //ok. float보다 double타입이 더 범위가 넓다.
```

그러나 리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터럴의 타입이 변수의 타입보다 저장범위가 넓으면
컴파일 에러가 발생한다.

```java
int i = 0x123456789; //에러. int타입의 범위를 넘는 값을 저장
float f = 3.14;      //에러. float 타입보다 double타입의 범위가 넓다.
```

3.14는 3.14d에서 접미사가 생략된 것으로 double타입이다.
이 값을 float 타입으로 표현 할 수 있지만, double타입의 리터럴이므로 float타입의 변수에 저장할 수는 없다.
|참고|
float는 접미사나 정밀도 등 신경 쓸 것이 많다. 이런 것들이 귀찮다면 그냥 double을 사용하자.

byte와 short 타입의 리터럴은 따로 존재하지 않으므로 int타입의 리터럴을 사용한다.
단, short타입의 변수가 저장할 수 있는 범위에 속한 것이어야 한다.

```java
byte b = 65;      //ok. byte타입에 저장 가능한 범위의 int타입 리터럴
short s = 0x1234; //ok. short타입에 저장 가능한 범위의 int타입 리터럴
```

각 타입의 저장 범위만 알아도 충분히 판단가능한 내용이다. 값의 크기에 상관없이 double타입의 리터럴을
float타입의 변수에 저장할 수 없다는 것만 주의하자. 보다 자세한 내용은 이 장의 마지막 다원인 
'형변환'에서 설명한다.

#### 문자 리터럴과 문자열 리터럴

'A'와 같이 작은 따옴표로 문자 하나를 감싼 것을 '문자 리터럴'이라고 한다. 두 문자 이상은
큰 따옴표로 감싸야 하며 '문자열 리터럴'이라고 한다.

|참고|문자열은 '문자의 연속된 나열'이라는 뜻이며, 영어로 'String'이라고 한다.

```java
char ch = 'J'; //char ch = 'java'; 이렇게 할 수 없다.
String name = "Java"; // 변수 name에 문자열 리터럴 "Java"를 저장
```

char타입의 변수는 단 하나의 문자만 저장할 수 있으므로, 여러 문자(문자열)를 저장하기 위해서는 
String타입을 사용해야 한다.
문자열 리터럴은 ""안에 아무런 문자도 넣지 않는 것을 허용하며, 이를 빈 문자열(emptyString)이라고 한다.
그러나 문자 리터럴은 반드시 ''안에 하나의 문자가 있어야한다.

```java
String str = ""; //ok. 내용이 없는 빈 문자열
char ch = '';    //에러. ''안에 반드시 하나의 문자가 필요
char ch = ' '; // ok. 공백 문자(blank)로 변수 ch를 초기화
```

원래 String은 클래스이므로 아래와 같이 객체를 생성하는 연산자 new를 사용해야 하지만 특별히
위와 같은 표현도 허용한다.

```java
String name = new String("Java"); //String 객체를 생성
```

그리고 덧셈 연산자를 이용하여 문자열을 결합할 수 있어서 다음과 같이 할 수 있다.

```java
String name = "Ja" + "va"; //name은 "Java"
String str = name + 8.0;   //str은 "Java8.0"
```

덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한 쪽이 String이면
나머지 한 쪽을 먼저 String으로 벼놘한 다음 두 String을 결합한다.
기본형과 참조형의 구별 없이 어떤 타입의 변수도 문자열과 덧셈연산을 수행하면 그 결과가 문자열이 되는 것이다.

```
문자열 + any type → 문자열 + 문자열 → 문자열
any type + 문자열 → 문자열 + 문자열 → 문자열
```

예를 들어 7 + "7"을 계산할 때 7이 String이 아니므로, 먼저 7을 String으로 변환한 다음 "7" + "7" 을 수행하여
"77"을 결과로 얻는다. 다음은 문자열 결합의 몇 가지 예를 보여준다.

```java
7 + " " → "7" + " " → "7 "
" " + 7 → " " + "7" → " 7"
    
7 + "7" → "7" + "7" → "77"
    
7 + 7 + "" → 14 + "" → "14" + "" → "14"
"" + 7 + 7 → "7" = 7 → "7" + "7" → "77"
    
true + "" → "true" + "" → "true"
null + "" > "null" + "" → "null"
```

덧셈 연산자는 왼쪽에서 오른쪽의 방향으로 연산을 수행하기 때문에 
결합순서에 따라 결과가 달라진다는 것에 주의하자. 그리고 7과 같은 기본형 타입의 값을 문자열로 변환할 때는
아무런 내용도 없는 빈 문자열("")을 더해주면 된다는 것도 알아두자.

---

### 2.3 형식화된 출력 - printf()

지금까지 화면에 출력할 때 println()을 써왔는데, println()은 사용하기엔 편하지만
변수의 값을 그대로 출력하므로, 값을변환하지 않고는 다른 형식으로 출력할 수 없다.
같은 값이라도 다른 형식으로 출력하고 싶을 때가 있다. 예를들면, 소수점 둘째자리까지만 출력한다던가,
정수를 16진수나 8진수로 출력한다던가. 이럴 때 printf()를 사용하면 된다.
printf()는 '지시자(specifier)'를 통해 변수의 값을 여러 가지 형식으로 변환하여 출력하는 기능을 가지고 있다.
'지시자'는 값을 어떻게 출력할 것인지를 지정해주는 역할을 한다. 
정수형 변수에 저장된 값을 10진 정수로 출력할 때는 지시자 '%d'를 사용하며, 
변수의 값을 지정된 형식으로 변환해서 지시자대신 넣는다. 예를 들어 int타입의 변수 age의 값이 14일 때,
printf()는 지시자 '%d'대신 14를 넣어서 출력한다.

```java
  System.out.pritf("age:%d", age);
 →System.out.pritf("age:%d", 14);
 →System.out.pritf("age:14" );   //"age:14"가 화면에 출력된다.
```

만일 출력하려는 값이 2개라면, 지시자도 2개를 사용해야하며 출력될 값과 지시자의 순서는 일치해야 한다.
물론 3개 이상의 값도 지시자를 지정해서 출력할 수 있으며 개수의 제한은 없다.

```java
 System.out.printf("age:%d year:%d", age, year);
→System.out.printf("age:%d year:%d", 14, 2017);  "age:14 year:2017"이 화면에 출력된다.
```

println()과 달리 printf()는 출력 후 줄바꿈을 하지 않는다. 줄바꿈을 하려면 지시자 '%n'을 따로 넣어줘야 한다.

|참고| ''%n' 대신 '\n' 을 사용해도 되지만, OS마다 줄바꿈 문자가 다를 수 있기 떄문에 
'%n'을 사용하는 것이 더 안전하다.

```java
System.out.printf("age: %d", age); //출력 후 줄바꿈을 하지 않는다.
system.out.printf("age:%d%n", age); //출력 후 줄바꿈을 한다.
```

|참고| 지시자의 전체 목록을 보려면, Java API에서 Formatter클래스 (java.util패키지)를 찾으면 된다.

printf()의 지시자 중에서 자주 사용되는 것만 뽑아보면 다음과 같다.

| 지시자 |                    설명                     |
| :----: | :-----------------------------------------: |
|   %b   |        불리언(boolean) 형식으로 출력        |
|   %d   |     10진(decimal) 정수의 형식으로 출력      |
|   %o   |       8진(octal) 정수의 형식으로 출력       |
| %x, %X |   16진(hexa-decimal)정수의 형식으로 출력    |
|   %f   | 부동 소수점(floating-point)의 형식으로 출력 |
| %e,%E  |    지수 (exponent)표현식의 형식으로 출력    |
|   %c   |           문자(character)로 출력            |
|   %s   |            문자열(String)로 출력            |

정수형 값을 printf()로 출력할 때는 지시자 '%d'를 사용하는데, 
출력될 값이 차지할 공간을 숫자로 지정할 수 있다. 여러 값을 여러 줄로 간격 맞춰 출력할 때 꼭 필요한 기능이다.
아래의 결과를 보면 '0'과 '-'가 어떤 역할을 하는지 설명하지 않아도 알 수 있을 것 이다.

```java
System.out.printf("finger = [%5d]\n", finger);    // finger = [   10]
System.out.printf("finger = [%-5d]\n", finger);   // finger = [10   ]
System.out.printf("finger = [%05d]\n", finger);   // finger = [00010]
```

지시자 '%'x'와 '%'o' 에 '#'를 사용하면 접두사 '0x'와 '0'이 각각 붙는다. 
그리고 '%X' 는 16진수에 사용되는 접두사와 영문자를 대문자로 출력한다.

```java
System.out.printf("hex = %x%n", hex); //hex = fffffffffff
System.out.printf("hex = %#x%n", hex); //hex = 0xfffffffffff
System.out.printf("hex = %#x%n", hex); //hex = 0Xfffffffffff
```

10진수를 2진수로 출력해주는 지시자는 없기 때문에, 정수를 2진 문자열로 변환해주는 
"Integer.toBinaryString(int i)"를 사용해야 한다. 이 메서드는 정수를 2진수로 변환해서
문자열로 반환하므로 지시자 '%s'를 사용했다.

```java
System.out.printf("binNum=%s\n", Integer.toBinaryString(binNum));
```

그리고 C언어에서는 char타입의 값을 지시자 '%d'로 출력할 수 있지만,
자바에서는 허용되지 않는다. 아래와 같이 int타입으로 형변환해야만 '%d'로 출력할 수 있다.

```java
System.out.printf("c = %c, %d \n", c, (int)c); //형변환이 꼭 필요하다.
```

```java
class PrintEx2 {
    public static void main(String[] args) {
        String url = "www.codechobo.com";
        
        float f1 = .10f; // 0.10, 1.0e-1
        float f2 = 1e1f; // 10.0, 1.0e1, 1.0e+1
        float f3 = 3.14e3f;
        double d = 1.23456789;
        
        System.out.printf("f1=%f, %e, %g%n", f1,f1,f1);
        System.out.printf("f2=%f, %e, %g%n", f2,f2,f2);
        System.out.printf("f3=%f, %e, %g%n", f3,f3,f3);
        
        System.out.printf("d=%f\n", d);
        System.out.printf("d=%14.10f\n",d); // 전체 14자리중 소수점 10자리
        
        System.out.printf("[12345678901234567890]\n");
        System.out.printf("[%s]\n",url);
        System.out.printf("[%20s]\n",url);
        System.out.printf("[%-20s]\n",url); //왼쪽 정렬
        System.out.printf("[%.8s]\n",url);  //왼쪽에서 8글자만 출력
    }
}
```

실수형 값의 출력에 사용되는 지시자는 '%f', '%e', '%g'가 있는데, '%f'가 주로 쓰이고 '%e'는 지수형태로 출력할 때, 
'%g'는 기본적으로 소수점 아래 6자리까지만 출력하기 때문에 소수점 아래 7자리에서 반올림한다.
그래서 1.23456789가 1.234568로 출력된다.

그리고 다음과 같이 전체 자리수와 소수점 아래의 자리수를 지정할 수도 있다.



%전체자리.소수점아래자리f 

예를들어 밑의 예제 출력결과는

```java
double d = 3.14159f;
System.out.printf("%4.3f",d); 
```

출력결과는 3.141

소수점도 한자리를 차지하며, 소수점 아래의 빈자리는 0으로 채우고 
정수의 빈자리는 공백으로 채워서 전체 자리수를 맞춘다.

지시자'%s'에도 숫자를 추가하면 원하는 만큼의 출력공간을 확보하거나 문자열의 일부만 출력할 수 있다.

```java
System.out.printf("[%s]\n", url); // 문자열의 길이만큼 출력공간을 확보
System.out.printf("[%20s]\n", url);// 최소 20글자 출력공간 확보. (우측정렬)
System.out.printf("[%-20s]\n", url);// 최소 20글자 출력공간 확보. (좌측정렬)
System.out.printf("[%.8s]\n", url);// 왼쪽에서 8글자만 출력
```

지정된 숫자보다 문자열의 길이가 작으면 빈자리는 공백으로 출력된다.
공백이 있는 경우 기본적으로 우측 끝에 문자열을 붙이지만, '-'를 붙이면 좌측 끝에 붙인다.
그리고 '.'을 붙이면 문자열의 일부만 출력할 수 있다. 

#### 2.4 화면에서 입력받기 - Scanner

지금까지는 화면에 출력만 해왔는데, 이제 화면으로부터 입력받는 방법에 대해서 배워보자.
자바에서 화면으로 부터 입력받는 방법은 여러 가지가 있으며, 점점 간단하고 편리한
방향으로 발전해 왔다. 최신 방법은 JDK1.6부터 추가된 Console 클래스를 이용하는 것인데,
이 클래스는 이클립와 같은 IDE에서 잘 동작하지 않으므로, 이와 유사한 Scanner클래스를 
이용해서 화면으로부터 입력받는 방법을 배워보자.

화면으로부터 입력받는 방법은 아직 배우지 않은 것들을 알아야 하는데도 불구하고
본인이 직접 입력을 하면 자칫 지루해 질 수 있는 내용들이 좀 더 재밌어지지 않을까하는
생각에서 미리 소개 하게 되었다. 
먼저 Scanner클래스를 사용하려면, 아래의 한 문장을 추가해줘야 한다.

```java
import java.util.*; //Scanner클래스를 사용하기 위해 추가
```

그 다음엔 Scanner클래스의 객체를 생성한다.

```java
Scanner scanner = new Scanner(System.in); //Scanner클래스의 객체를 생성
```

그리고 nextLine()이라는 메서드를 호출하면, 입력대기 상태에 있다가 입력을 마치고
'엔터키(Enter)'를 누르면 입력한 내용이 문자열로 반환된다.

```java
String input = scanner.nextInt //입력받은 내용을 input에 저장
int num = Integer.parseInt(input) //입력받은 내용을 input타입의 값으로 변환
```

만일 입력받은 문자열을 숫자로 변환하려면, Interger.parseInt()라는 메서드를 이용해야한다.
이 메서드는 문자열을 int타입의 정수로 변환한다.

|참고|

다른 타입으로의 변환은 책 493p참고

사실 Scanner클래스에는 nextInt()나 nextFloat()와 같이 변환없이 숫자로 바로 입력받을 수 있는
메서드를 메서드들이 있고, 이 메서드들을 사용하면 문자열을 숫자로 변환하는
수고는 하지 않아도 된다.

```java
int num = scanner.nextInt(); //정수를 입력받아서 변수 num에 저장
```

그러나 이 메서드들은 화면에서 연속적으로 값을 입력받아서 사용하기에 까다롭다.
차라리 모든 값을 nextLine()으로 입력받아서 적절히 변환하는 것이 더 낫다.

```java
import java.util.*;

class ScannerEx {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.print("두자리 정수를 하나 입력해주세요.>");
        String input = scanner.nextLine();
        int num = Integer.parseInt(input); //입력받은 문자열을 숫자로 변환
        
        System.out.println("입력내용 :" + input);
        System.out.printf("num = %d\n",num);
    }
}
```

실행결과 

두자리 정수를 하나 입력해주세요> 22
입력내용 : 22
num= 22

만일 숫자가 아닌 문자 또는 기호를 입력하면, 입력받은 문자열을 숫자로 변환하는 과정
인 Integer.parseInt()에서 에러가 발생한다. 특히 공백을 입력하지 않도록 주의하자.

---

## 3. 진법  042-050 p

### 3.1 10진법과  2진법

우리는 일상생활에서 주로 사용하는 것은 10진법이다. 아마도 사람이 10개의 손가락을 가지고 있기
때문이 아닐까. 1946년에 개발된 컴퓨터인 에니악(ENIAC)은 사람에게 익숙한 10진법을 사용하도록
설계되었으나 전기회로는 전압이 불안정해서 전압을 10단계로 나누어 처리하는 데 한계가 있었다.
그래서 1950년에 개발된 에드박(EDVAC)은 단 두가지 단계, 전기가 흐르면 1, 흐르지 않으면0,
만으로 동작하도록 설계되었고 매우 성공적이었다.
손가락의 개수가 10개인 사람에게 10진법이 적합하듯, 컴퓨터와 같은 전기회로에는 
2진법이 적합한 것이다. 그 이후부터 지금까지 대부분의 컴퓨터는 2진 체계로 설계되었기
때문에, 2진법을 알지 못하면 컴퓨터의 동작원리나 데이터 처리방식을 온전히 이해할 수 없다.
지금까지 변수에 값을 저장하면 10진수로 저장되는 것처럼 설명을 하였지만, 컴퓨터는
2진수(0과 1)밖에 모르기 때문에 아래의 오른쪽과 같이 2진수로 바뀌어 저장된다.
2진수 11001은 10진수로 25이다.

```java
int age = 25; //변수 age에 25를 저장
```

이처럼 2진법은 0과 1로만 데이터를 표현하기 때문에 10진법에 비해 많은 자리수를 필요로 한다.
10진수 2와 같이 작은 숫자도 2진수로 표현하려면 2자리가 필요하다. 2진수 한자리로는
1보다 큰 값을 표현할 수 없기 때문이다.
이것은 10진수에서 9보다 큰 수를 표현하기 위해서는 두 자리의 10진수가 필요한 것과 같다.
그래서 2진수 1에 1을 더하면 2가 아닌 10이 되고, 2진수 11에 1을 더하면 12가 아닌 100이 된다.
10진수와 비교해보면 쉽게 이해가 될 것이다.

자리수가 많아지긴 해도 2진수는 10진수를 온전히 표현할 수 있다.
게다가 덧셈이나 뺄셈같은 연산도 10진수와 동일하다.

### 3.2 비트(bit)와 바이트(byte)

한 자리의 2진수를 '비트(bit, binary dight)'라고 하며, 1비트는 컴퓨터가 값을 저장할 수 있는 
최소 단위이다. 그러나 1비트는 너무 작은 단위이기떄문에 1비트 8개를 묶어서 '바이트(byte)'라는
단위로 정의해서 데이터의 기본 단위로 사용한다.

이 외에도 '워드(word)'라는 단위가 있는데, 워드 는 CPU가 한 번에 처리할 수 있는
데이터의 크기 를 의미한다.
워드의 크기를 4바이트 라고 했지만, 사실 워드의 크기는 CPU의 성능에 따라 달라진다.
예를 들어 32비트 CPU에서 1워드는 32비트 (4 바이트)이고, 64비트 CPU에서는 64비트(8바이트)이다.

아래의 표는 1~4비트로 표현할 수 있는 값의 개수를 모두 나열한 것으로 1비트 (2진수 1자리)로 
0과 1, 모두 2개(2¹)의 값을, 2비트(2진수 2자리)로는 4개(2²)의 값을 표현할 수 있다는것을 알수있다.

이를 일반화하면, n비트로 2n개의 값을 표현할 수 있다. 그리고 n비트로 10진수를 표현한다면,
표현가능한 10진수의 범위는 0~2n-1이 된다.
4비트로 모두 16개 (2^4)의 값을 표현할 수 있으며, 4비트로 10진수를 표현한다면 범위가
'0 ~15(0 ~ 2^4 - 1)'라는 것을 직접 확인할 수 있다.

```
n 비트로 표현할 수 있는 10진수
값의 개수 : 2n
값의 범위 : 0 ~ 2n-1
```

|참고| 10진수 n자리로 표현할 수 있는 값의 범위가 '0~10n-1'라는 것과 비교해보면 이해가 더 쉬울 것이다.
10진수 2자리로 표현할 수 있는 값의 범위는 '0~10^2-1', 즉 '0~99'가 된다.

#### 3.3 8진법과 16진법

2진법은 오직 0과 1, 두 개의 기호만으로 값을 표현하기 때문에, 2진법으로 값을 표현하면 자리수가 
상당이 길어진다는 단점이 있다. 이러한 단점을  보완하기 위해 2진법 대신 8진법이나 16진법을 사용한다.
8진수는 2진수 3자리를, 16진수는 2진수 4자리를 각각 한자리로 표현할 수 있기 때문에 자리수가 짧아져서
알아보기 쉽고 서로 간의 변환방법 또한 매우 간단하다.

8진법은 값을 표현하는데 8개의 기호가 필요하므로 0~7의 숫자를 기호로 사용하면 되지만,
16진법은 16개의 기호가 필요하므로 0~9의 숫자만으로는 부족하다. 그래서 6개의 문자(A~F)를 추가로 사용한다.
예를 들어 16진수 A는 10진수로 10이고 , F는 15이다.

2진법 - 0 , 1 - 2개
8진법 - 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7  - 8 개
10진법 - 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9  - 10개
16진법 - 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9  , A , B , C , D , E , F - 16개

---

## 4.기본형(primitive type)

기본형의 세부적인 내용

### 4.1 논리형 - boolean

논리형에는 'boolean'한가지 밖에 없다. boolean 형 변수에는 true와 false 중 하나를 저장할 수 있으며 
기본값(default)은 false이다.
boolean형 변수는 대답(yes/no), 스위치 (on/off) 등의 논리구현에 주로 사용된다.
그리고 boolean형은 true와 false, 두 가지의 값만을 표현하면 되므로 1bit 만으로도 충분하지만,
자바에서는 데이터를 다루는 최소단위가 byte이기 때문에, boolean의 크기가 1byte이다. 
아래 문장은 power라는 boolean형 변수를 선언하고 true로 변수를 초기화 했다.

```java
boolean power = true;
boolean checked = False; // 에러. 대소문자가 구분됨. true 또는 false만 가능
```

자바에서는 대소문자가 구별되기 때문에 TRUE와 true는 다른 것으로 간주된다는 것에 주의하자.

### 4.2 문자형 - char

문자형 역시 'char'한 가지 자료형밖에 없다. 문자를 저장하기 위한 변수를 선언할 때 사용되며, 
char타입의 변수는 단 하나의 문자만을 저장할 수 있다. 아래의 문장은 char타입의 변수 ch를 선언하고,
문자 'A'로 초기화한다.

```java
char ch = 'A'; //문자 'A'를 char타입의 변수 ch에 저장.
```

위의 문장은 변수에 '문자'가 저장되는 것 같지만, 사실은 문자가 아닌 '문자의 유니코드(정수)'가 저장된다.
컴퓨터는 숫자밖에 모르기 떄문에 모든 데이터를 숫자로 변환하여 저장하는 것이다. 문자'A'의 유니코드는 65이므로,
변수 ch에는 65가 저장된다.

그래서 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.
문자'A'의 유니코드는 10진수로 65이며, 아래의 두 문장은 동일한 결과를 얻는다.

```java
char ch = 'A'; //문자 'A'를 char타입의 변수 ch에 저장.
char ch = 65; // 문자의 코드를 직접 변수 ch에 저장
```

만일 어떤 문자의 유니코드를 알고 싶으면, char형 변수에 저장된 값을 정수형(int)으로 변환하면 된다.

```java
int code = (int)ch; //ch에 저장된 값을 int 타입으로 변환하여 저장하낟.
```

어떤 타입(type, 형)을 다른 타입으로 변환하는 것을 형변환(캐스팅, casting)이라고 하는데, 
형변환에 대해서는 이장의 마지막에 자세히 설명할 것이다. 지금은 문자의 유니코드를 알아내는 방법과
어떤 유니코드가 어떤 문자를 나타내느가를 알아내는 방법이 있다는 것만 이해하고 넘어가자.

```java
class charToCode {
    public static void main(String[] args){
        char ch ='A'; // char ch = 65;
        int code = (int)ch; //ch에 저장된 값을 int타입으로 변환하여 저장한다.
        
        System.out.printf("%c=%d(%#X) \n", ch, code, code);
        
        char hch = '가'; //char hch = 0xAC00;
        System.out.printf("%c=%d(%#X)\n",hch , (int)hch, (int)hch);
    }
}
```

실행 결과 
A= 65 (0X41)
가=44032 (0XAC00)

실행 결과를 보면, 문자'A'의 유니코드는 65(16진수로 0x41)이고,
문자 '가'의 유니코드는 44032(16진수로 0xAC00)이라는 것을 알 수 있다. 
유니코드를 알면 아래와 같이 char형 변수에 문자를 저장할 때, 
문자 리터럴 대신에 유니코드를 직접 사용할 수도 있다.

```java
char hch = 0xAC00;   //char hch = '가';
char hch = '\uAC00'; //이렇게도 가능
```

#### 특수 문자 다루기

영문자 이외에 tab이나 backspace 등의 특수문자를 저장하려면 아래와 같이 조금 특별한 방법을 사용한다.

```java
char tab = '\n'; // 변수 tab에 탭 문자를 저장
```

'\ㅅ'는 실제로는 두 문자로 이루어져 있지만 한 문자(탭,tab)를 의미한다.
 아래의 표는 탭 (tab)과 같이 특수한 문자를 어떻게 표현할 수 있는지 알려준다.

|       특수문자       |           문자 리터럴           |
| :------------------: | :-----------------------------: |
|         tab          |               \t                |
|      backspace       |               \b                |
|      form feed       |               \f                |
|       new line       |               \n                |
|   carriage return    |               \r                |
|     역슬래쉬(\|)     |              \\ \               |
|     작은 따옴표      |               \ '               |
|      큰 따옴표       |               \ "               |
| 유니코드(16진수)문자 | \u유니코드 (예:char a='\u0041') |

▲특수문자를 표현하는 방법

#### char타입의 표현방식

char타입의 크기는 2byte(=16bit)이므로, 16자리의 2진수로 표현할 수 있는정수의 개수인 65536개(=2^16)의 코드를
사용할 수 있으며, char형 변수는 이 범위 내의 코드 중 하나를 저장할 수 있다. 예를 들어, 문자 'A'를 저장하면,
아래와 같이 2진수 '0000000010000001''(10진수로 65)로 저장된다.

char타입은 문자를 저장할 변수를 선언하기 위한 것이지만, 
실제로 char타입의 변수에는 문자가 아닌 '문자의 유니코드(정수)'가 저장되고 표현형식 역시 정수형과 동일하다.
다만, 정수형과 달리 음수를 나타낼 필요가 없으므로 표현할 수 있는 값의 범위가 다르다.
2 byte(=16 bit)로는 모두 2^16(65536)개의 값을 표현할 수 있는데, char타입에 저장되는 값인 유니코드는
모두 양수(0 포함)이므로, '0~65535'의 범위를 가지며, 정수형인 'short'은 절반을 음수표현에 사용하므로
'-32768~32767'을 범위로 갖는다.

16비트로 표현할 수 있는 정수의 개수 : 2^16개 (65536개)

short타입의 표현범위 : -2^15 ~ 2^15 -1 (-32768 ~32767)
char 타입의 표현범위: 0~ 2^16-1 (0~ 65535)

다음과 같이 변수 ch와 s에 'A'와 65를 저장하면, 둘 다 2진수로 똑같은 값이 저장된다.
컴퓨터는 모든 값을 0과 1로 바꾸어 저장하기 때문이다.

```java
char ch = 'A'; //char ch = 65;
short s =  65;
```

그런데도 두 변수의 값을 출력해보면 결과가 다르다. println()은 변수의 타입이 정수형이면
변수에 저장된 값을 10진수로 해석하여 출력하고,
문자형이면 저장된 숫자에 해당하는 유니코드 문자를 출력하기때문이다.

```java
System.out.println (ch); // A가 출력된다.
System.out.println (s);  // 65가 출력된다.
```

이처럼 값은 어떻게 해석하느냐에 따라 결과가 달라지므로 값만으로는 값을 해석할 수 없다.
값의 타입까지 알아야 올바르게 해석할 수 있는 것이다. 예를들어 '1231'이라는 값이 있을 때,
이 값의 타입을 모르면, 이 값을 '천이백삼십일'로 해석해야할지, 
아니면 12월31일이나 12시 31분으로 해석해야 할지 알 수 없다.

인코딩과 디코딩(encoding & decoding)

컴퓨터가 숫자밖에 모르기 때문에 문자가 숫자로 변환되어 저장된다는 것은 알겠는데,
그러면 도대체 어떤 기준에 의한 것일까? 바로 아래에 있는 표에 의한 것인데, 이 코드표는
'유니코드(unicode)'이다.

| 문자 | 유니 코드 |
| :--: | --------- |
|  A   | 65        |
|  B   | 66        |
|  C   | 67        |



```java
'A' > 65 //인코딩
'A' < 65 //디코딩 
```

위의 그림에서 오른쪽 표를 보면, 문자'A'의 유니코드가 65인 것을 알 수 있다.
그래서 문자'A'를 유니코드로 인코딩하면 65가 되는 것이다. 반대로 65를 유니코드로 디코딩하면 문자'A'가 된다.
이처럼 문자를 코드로 변환하는 것을 '문자 인코딩(encoding)', 
그 반대로 코드를 문자로 변환하는 것을 '문자 디코딩(decoding)'이라고 하며, 문자를 저장할 떄는 인코딩을 해서
숫자로 변환해서 저장하고, 저장된 문자를 읽어올 때는 디코딩을 해서 숫자를 원래의 문자로 되돌려야 한다.

|참고|'encode'는 '~을 코드화하다.'또는 '을 암호화하다.'라는 뜻이다.

당연한 얘기지만 어떻게 인코딩을 했는지를 알아야 디코딩이 가능하다.
만일 인코딩에 사용된 코드표와 디코딩에 사용된 코드표가 다르면 엉뚱한 글자들로 바뀌어 나타날 것이다.
웹서핑을 하다가 페이지 전체가 알아볼 수 없는 이상한 글자들로 가득 찬 경험이 적어도
한부 번쯤은 있을 텐데, 그 이유는 해당 html문서의 인코딩에 사용된 코드표와 웹브라우저의 설정이 맞지 않아서이다.
대부분의 경우 웹페이지(html파일)에 인코딩 정보가 포함되어 있어서 웹브라우져가 올바르게 디코딩하지만,
웹브라우져의 인코딩 설정이 웹페이지의 인코딩과 다른경우 글자가 알아볼 수 없게 깨져서 나타난다.

#### 아스키

'ASCII'는 'American Standard Code for information Interchange'의 약어로 정보교환을 위한 미국 표준 코드란 뜻이다.
아스키는 128개(=2^7의 문자 집합(character set)을 제공하는 7bit 부호로,
처음 32개의 문자는 인쇄와 전송 제어용으로 사용되는 '제어문자(control character)'로 출력할 수 없고
마지막 문자 (DEL)를 제외한 33번째 이후의 문자들은 출력할 수 있는 문자들로, 기호와 숫자, 영대소문자로 이루어짐
아스키는 숫자 '0~9', 영문자 'A~Z'와 'a~z'가 연속적으로 배치되어 있다는 특징이 있으며,
이러한 특징은 프로그래밍에서 유용하게 활용된다.

#### 확장 아스키(Extended ASCII)와 한글

일반적으로 데이터는 byte단위로 다뤄지는데 아스키는 7bit 이므로 1bit가 남는다. 이 남는 공간을 활용해서
문자를 추가로 정의한 것이 '확장 아스키'이다. 확장 아스키에 추가된 128개의 문자는 여러국가와 기업에서
서로의 필요에 따라 다르게 정의해서 사용한다.
'ISO(국제표준화기구)'에서 확장 아스키의 표준을 몇 가지 발표했는데, 그 중에서 대표적인 것이
'ISO 8859 - 1'이다. 이 확장 아스키 버전은 'ISO Latin 1'이라고도 하는데
서유럽에서 일반적으로 사용하는 문자들을 포함하고 있다.

확장 아스키로도 표현할 수 있는 문자의 개수가 255개 뿐이므로 한글을 표현하기에는 턱없이 부족하다.
그래서 생각해낸 것이 두 개의 문자코드로 한글을 표현하는 방법이었다.
한글을 표현하는 방법은 조합형과 완선형이 있는데, 조합형은 초성, 중성, 종성을 조합하는 방식이고,
완셩형은 확장 아스키의 일부 영역(162,254)에 해당하는 두 문자코드를 조합하여 한글을 표현한다.
현재 조합형은 사용되지 않고 '완성형(KSC 5601)'에 없는 잘 안 쓰이는 8822글자를 추가한 '확장 완성형(CP 949)'이
사용되는데, 이것이 한글 윈도우에서 사용하는 문자 인코딩이다. 한글 윈도우에서 작성된 문서는 기본적으로 
'CP949(확장 완성형)'로 인코딩되어 저장된다.

#### 코드 페이지(code page, cp) 

IBM이 자사의 PC에 '확장 아스키'를 도입해서 사용하기 시작할 때, PC를 사용하는 지역이나
국가에 따라 여러 버전의 '확장 아스키' 가 필요했다. IBM은 이들을 '코드 페이지(code page)'라 하고,
각 코드 페이지에 'CP xxx'와 같은 형식으로 이름을 붙였다. IBM은 MS와 같은 업체들과 협력하여 
'코드 페이지'를 만들어내고 공유했다. 한글 윈도우는 'CP949'를, 영문위도우는 'CP 473'을 사용한다

|참고| 코드 페이지는 확장 아스키의 256개 문자를 어떤 숫자로 변환할 것인지를 적어놓은 '문자 코드표'일뿐이다.

#### 유니코드(Unicode)

예전엔 같은 지역 내에서만 문서교환이 주를 이뤘지만, 인터넷이 발명되면서 서로다른 지역의 다른 언어를 사용하는
컴퓨터간의 문서교환이 활발해지기 시작하자 서로 다른 문자 인코딩을 사용하는 컴퓨터간의 문서교환에 어려움을
겪게 되었다.
이러한 어려움을 해소하고자 전 세계의 모든 문자를 하나의 통일된 문자집합으로 표현하고자 노력하였고
그 결과가 바로 '유니코드'이다.
유니코드는 처음엔 모든 문자를 2 byte(=2^16-65536)로 표현하려 했으나, 2byte (=16bit)로도 부족해서 
21bit(약 200만 문자)로 확장되었다. 새로 추가된 문자들을 보충문자(supplementary character)라고 하는데
이 문자들을 표현하기 위해서는 char타입이 아닌 int타입을 사용해야 한다. 
우리가 보충문자를 쓸 일은 거의 없기 떄문에 참고로만 알아두면 된다.
유니코드는 먼저 유니코드에 포함시키고자 하는 문자드르이 집합을 정의하였는데, 이것을 유니코드 문자셋
(또는 캐릭터 셋,character set)이라고 한다. 그리고 이 문자 셋에 번호를 붙인 것이 유니코드 인코딩이다.
유니코드 인코딩에는 UTF-8 , UTF-16, UTF-32등 여러 가지 종류가 있는데 자바에서는 UTF-16을 사용한다.
UTF-16은 모든 문자를 2byte의 고정크기로 표현하고 UTF-8은 하나의 문자를 1~4byte의 가변크기로 표현한다.
그리고 두 인코딩 모두 처음128문자가 아스키와 동일하다.아스키를 그대로 포함하고 있는 것이다.

모든 문자의 크기가 동일한 UTF-16이 문자를 다루기는 편리하지만, 1byte로 표현할 수 있는 영어와 숫자가
2 byte로 표현되므로 문서의 크기가 커진다는 단점이 있다. UTF-8에서 영문과 숫자는 1byte그리고
한글은 3byte로 표현되기 때문에 문서의 크기가 작지만 문자의 크기가 가변적이므로 다루기 어렵다는 단점이 있다.
인터넷에서는 전송속도가 중요하므로, 문서의 크기가 작을수록 유리하다. 그래서 UTF-8인코딩으로 작성된
웹문서의 수가 빠르게 늘고 있다.

### 4.3 정수형-  byte, short, int, long

정수형에는 모두 4개의 자료형이 있으며, 각 자료형이 저장할 수 있는 값의 범위가 서로 다르다.
크기순으로 나열하면 다음과 같다. 단위는 byte이다.

```
byte < short < int < long
 1       2      4      8
```

byte부터 long까지 1byte부터 시작해서 2배씩 크기가 증가한다는 것을 알 수 있다. 
이중에서도 기본 자료형(default data type)은 int이다.

#### 정수형의 표현방식과 범위

어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장된다. 이 2진수가 저장되는 형식은
크게 정수형과 실수형이 있으며, 정수형은 다음과 같은 형식으로 저장된다.

```
S  n-1 bit
```

S : 부호 비트(양수는 0, 음수는 1)
n : 타입의 크기(단위: bit)

모든 정수형은 부호있는 정수이므로 왼쪽의 첫 번째 비트를 '부호 비트(sign bit)'로 사용하고, 나머지는
값을 표현하는데 사용한다. 그래서  n비트로 표현할 수 있는 값의 개수인 2^n개에서, 절반인 '0'으로
시작하는 2n-1개의 값을 양수(0도 포함)의 표현에 사용하고, 나머지 절반인 '1'로 시작하는 2n-1개의 값은
음수의 표현에 사용한다.

그래서 정수형은 타입의 크기만 알면, 최대값과 최소값을 쉽게 계산해낼 수 있다.



```
n비트로 표현할 수 있는 정수의 개수 : 2n개 (=2^n-1개 + 2^n-1개)
n비트로 표현할 수 있는 부호있는 정수의 범위: -2^n-1 ~ 2%n-1 -1 
```

위의 범위의 최대값에서 1을 빼는 이유는 범위에 0이 포함되기 때문이다. 예를 들어 byte의 경우 
크기가 1byte(=8 bit)이므로, byte타입의 변수에 저장할 수 있는 값의 범위는 '-128,127'이다.



이처럼 타입의 크기만 알면, 모든 정슈형의 표현범위를 쉽게 계산해낼 수 있다.

#### 정수형의 선택기준

변수에 저장하려는 정수값의 범위에 따라 4개의 정수형 중에서 하나를 선택하면 되겠지만, byte나 short보다
int를 사용하도록 하자. byte와 short이 int보다 크기가 작아서 메모리를 조금더 절약할 수는 있지만,
저장할 수 있는 값의 범위가 작은 편이라서 연산 시에 범위를 넘어서 잘못된 결과를 얻기가 쉽다.
그리고 JVM의 피연산자 스택(operand stack)이 피연산자를 4byte단위로 저장하기 때문에 크기가 4 byte보다
작은 자료형 (byte,short)의 값을 계산할 때는 4byte로 변환하여 연산이 수행된다. 그래서 오히려 int를 사용하는 것이
더 효윻적이다. 
int 타입의 크기는 4 byte(=32 bit)이므로 , 표현할 수 있는 정수의 개수는 약 40억이며, 표현 가능한 정수의 범위는
약 20억이다.

결론적으로 정수형 변수를 선언할 때는 int타입으로 하고, int의 범위(약 20억)을 넘어서는 수를 다뤄야할때는
long을 사용하면 된다. 그리고 byte나 short은 성능보다 저장공간을 절약하는 것이 더 중요할 때 사용하자.

#### 정수형의 오버플로우

만일 4 bit 2진수의 최대값인 '1111'에 1을 더하면 어떤 결과를 얻을까?
4 bit의 범위를 넘어서는 값이 되기 때문에 에러가 발생할까?

원래 2진수 '1111'에 1을 더하면 '10000'이 되지만, 4bit로는 4자리의 2진수만 저장할 수 있기 때문에 '0000'이 된다.
즉, 5자리의 2진수 '10000'중에서 하위 4bit만 저장하게 되는것이다.
이처럼 연산과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우(overflow)라고 한다.
오버플로우가 발생했다고 해서 에러가 발생하는 것은 아니다. 다만 예상했던 결과를 얻지 못할 뿐이다.
애초부터 오버플로우가 발생하지 않게 충분한 크기의 타입을 선택해서 사용해야한다.

오버플로우는 '자동차 주행표시기'나, '계수기(counter)'등 우리의 일상생활에서도 발견할 수 있는데,
네 자리 계수기라면 '0000'부터 '9999'까지 밖에 표현하지 못하므로 최대값인 '9999'다음의 숫자는
'0000'이 될 것이다. 원래는 10000이 되어야 하는데 다섯 자리는 표현할 수 없어서 맨 앞의 1은 버려지기 때문이다.
그러면 이번엔 반대로 최소값인 '0000'에서 1을 감소시키면 어떤 결과를 얻을까? 0에서 1을 뺄 수 없으므로
'0000'앞에 저장되지 않은 1이 있다고 가정하고 뺄셈을 한다.

그래서 정수형 타입이 표현할 수 있는 최대값에 1을 더하면 최소값이 되고, 최소값에서 1을 빼면 최대값이 된다.

```
최대값 +1 → 최소값
최소값 -1 → 최대값
```



#### 부호있는 정수의 오버플로우

부호없는 정수와 부호있는 정수는 표현범위 즉, 최대값과 최소값이 다르기 때문에
오버플로우가 발생하는 시점이 다르다. 부호없는 정수는 2진수로 '0000'이 될 때 오버플로우가 발생하고,
부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생한다.

부호없는 정수의 경우 표현범위가 '0~15'이므로 이 값이 계속 반복되고, 
부호있는 정수의 경우 표현범위가 '-8~-7'이므로 이 값이 무한히 반복된다.



쉽게 정리하면 
최소값 - 1  = 최대값 
최대값 + 1 = 최소값

### 4.4 실수형 -float,double

#### 실수형의 범위와 정밀도

실수형은 실수를 저장하기 위한 타입으로 float와 double, 
두 가지가 있으며 각 타입의 변수에 저장할 수 있는 값의 범위는

float 7자리 double 15자리

실수형은 소수점수도 표현해야 하므로 '얼마나 큰 값을 표현할 수 있는가'뿐만 아니라
'얼마나 0에 가깝게 표현할 수 있는가'도 중요하다.

```java
실수형에서도 변수의 값이 표현범위의 최대값을 벗어나면 '오버플로우'가 발생하는데
정수형과 달리 실수형에서는 오버플로우가 발생하면 변수의 값은'무한대(infinity)'가 된다.
그리고 정수형에는 없는 '언더플로우(underflow)'가 있는데. '언더플로우'는 실수형으로 표현할 수 없는
아주 작은 값, 즉 양의 최소 값보다 작은 값이 되는 경우를 말한다. 이때 변수의 값은 0이 된다.
```

만일 7자리 이상의 정밀도가 필요하다면, 변수의 타입을 double로 해야 한다.
double타입은 float타입보다 정말도가 약 2배인, 10진수로 15자리의 정밀도를 가지므로 
float타입보다 훨씬 더 정밀하게 값을 표현할 수 있다. 
실수형 값을 저장할 때, float타입이 아닌 double타입의 변수를 사용하는 경우는 대부분 저장하려는 '값의 범위'때문이
아니라 '보다 높은 정밀도'가 필요해서이다.

|참고| double이라는 이름은 float보다 약 2배(double)의 정밀도를 갖는다는 의미에서 붙여진 것이다.

연산 속도의 향상이나 메모리를 절약하려면 float를 선택하고, 더 큰 값의 범위라던가 
더 높은 정밀도를 필요로 한다면 double를 선택해야 한다.

실수형 값을 출력할 때는 printf메서드의 지시자 '%f를 사용한다.' 
'%f'는 기본적으로 소수점이하 6자리까지만 출력하므로, 7번째 자리에서 반올림되어 '9.123457'이 되었다.

```java
System.out.printf("f : %f\n", f); // f : 9.123457
```

앞서 배운 것처럼, '%24.20f'는 전체 24자리 중에서 20자리는 소수점 이하의 수를 출력하라는 뜻이다.

저장공간의 한계로 오차가 발생할수 있다.

#### 실수형의 저장형식

앞서 언급한 바와 같이 실수형은 정수형과 표현형식이 달라서, 
실수형은 값을 부동 소수점수(floating-point)의 형태로 저장한다. 부동소수점수는 부호(Sign),지수(Exponent),
가수(Mantissa), 모두 세 부분으로 이루어져 있다.

```
±Mx2^E
```

위와 같은 표현형식은 IEEE754라는 표준을 따른 것인데, IEEE754는 '전기 전자 기술자 협회에서 재정한
부동소수점수의 표현방법이다.

| 기호 |      의미      |                             설명                             |
| :--: | :------------: | :----------------------------------------------------------: |
|  S   | 부호(Sign bit) |                    0이면 양수, 1이면 음수                    |
|  E   | 지수(Exponent) | 부호있는 정수. 지수의 범위는 <br />-127 ~ 128 (float), -1023~1024(double) |
|  M   | 가수(Mantissa) | 실제값을 저장하는 부분.<br />10진수로 7자리(float), 15자리(double)의 정밀도로 저장가능 |

#### 1.부호 (sign bit)

'S는 부호비트(sign bit)를 의미하며 1 bit이다. 이 값이 0이면 양수를, 1이면 음수를 의미한다.
정수형과 달리 '2의 보수법'을 사용하지 않기 때문에 양의 실수를 음의 실수로 바꾸려면
그저 부호비트만 0에서 1로 변경하면 된다.

#### 2.지수(Exponent)

'E'는 지수를 저장하는 부분으로 float의 경우, 8 bit의 저장공간을 갖는다. 지수는 '부호있는 정수'이고
8bit로는 모두 2의 8제곱(=256)개의 값을 저장할 수 잇으므로, '-127~128'의 값이 저장된다. 이중에서 
-127과 128은 '숫자 아님(NaN, Not a Number)'이나
 '양의 무한대(POSITIVE_INFINITY)','음의 무한대(NEGATIVE_INFINITY)'와 같이 특별한 값의 표현을 위해
에약되어 있으므로 실제로 사용가능한 지수의 범위는'-126~127'이다. 그래서 지수의 최대값이 127이므로
float타입으로 표현할 수 있는 최대값은 2^127이고 10진수로 약 10^38이다. 그러나 float의 최소값은
가수의 마지막 자리가 2^-23이므로 지수의 최소값보다 2^-23배나 더 작은 값, 약 10^-45이다.

#### 3.가수(Mantissa)

'M'은 실제 값인 가수를 저장하는 부분으로 float의 경우, 2진수 23자리를 저장할 수 있다. 
2진수 23자리로는 약 7자리의 10진수르 저장할 수 있는데 이것이 바로 float의 정밀도가 된다.
double은 가수를 저장할 수 있는 공간이 52자리로 float보다 약 2배이므로
double이 float보다 약 2배의 정밀도를 갖는 것이다.

#### 부동소수점의 오차

실수 중에는 '파이'와 같은 무한소수가 존재하므로, 정수와 달리 실수를 저장할 떄는 오차가 발생할 수 있다.
게다가 10진수가 아닌 2진수로 저장하기 때문에 10진수로는 유한소수이더라도, 2진수로 변환하면
무한소수가 되는 경우도 있다. 2진수로는 10진 소수를 정확히 표현하기 어렵기 때문이다.

비록 2진수로 유한소수라도, 가수를 저장할 수 있는 자리수가 한정되어 있으므로 
저장되지 못하고 버려지는 값들이 있으면 오차가 발생한다. 
2진수로 변환된 실수를 저장할 때는 먼저'1.xxx * 2^n'의 형태로 변환하는데,
이 과정을 정규화라고 한다.

---

## 5.형변환

### 5.1 형변환(캐스팅, casting)이란?

모든 변수와 리터럴에는 타입이 있다는 것을 배웠다.
프로그램을 작성하다 보면 같은 타입뿐만 아니라 서로 다른 타입간의 연산을 수행해야하는 경우도
있다. 이럴 때는 연산을 수행하기 전에 타입을 일치시켜야 하는데, 변수나 리터럴의 타입을
다른 타입으로 변환하는 것을 '형변환'이라고 한다.

```
형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
```

예를 들어 int 타입의 값과 float타입의 값을 더하는 경우, 먼저 두 값을 같은 타입으로 즉,
둘 다 float타입으로 변환한 다음에 더해야 한다.

### 5.2 형변환 방법

형변환 방법은 아주 간단하다. 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을
괄호화 함께 붙여주기만 하면 된다.

```
(타입)피연산자	
```

여기서 사용되는 괄호()는 '캐스트 연산자' 또는 '형변환 연산자'라고 하며,
형변환을 '캐스팅(casting)'이라고도 한다.

예를들어 다음과 같은 코드가 있을 떄,

```java
double d = 85.4;
int score = (int)d; //double타입의 변수 d를 int 타입으로 형변환
```

두 번째 줄의 연산과정을 단계별로 살펴보면 다음과 같다.

```java
 int score = (int)d;
→int score = (int)85.4; //변수 d의 값을 읽어 와서 형변환한다.
→int score = 85;        //형변환의 결과인 85를 변수 score에 저장한다.
```

이 과정에서 알 수 있듯이, 형변환 연산자는 그저 피연선자의 값을 읽어서 
지정된 타입으로 형변환하고 그 결과를 반환할 뿐이다.
그래서 피연산자인 변수 dㅡ이 값은 형변환 후에도 아무런 변화가 없다.

```java
class Castring {
    public static void main(String[] args) {
        double d = 85.4;
        int score = (int)d;
        
        System.out.println("score="+score);
        System.out.println("d="+d);
    }
}
```

실행결과 

```java
score=85
d=85.4    //형변환 후에도 피연산자에는 아무런 변화가 없다.
```

기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하다.
그리고 기본형과 참조형간의 형변환은 불가능하다. 여기서는 기본형의 형변환에 대해서만 다룬다.

|    변환     |   수식    | 결과  |
| :---------: | :-------: | :---: |
| int → char  | (char)65  |  'A'  |
|  char →int  | (int)'A'  |  65   |
| float → int | (int)1.6f |   1   |
| int → float | (float)10 | 10.0f |

▲기본형간의 형변환

위 표는 형변환의 몇 가지 예를 보여준다. float타입의 값을 int타입으로 변환할 때
소수점 이하의 값은 반올림이 아닌 버림으로 처리된다는 점을 눈여겨보자.
이제 각 타입간의 변환을 하나씩 자세히 살펴보자.

### 5.3 정수형간의 형변환

큰 타입에서 작은 타입으로의 변환, 예를 들어 int타입(4byte)의 값을 byte타입(1byte)으로
변환하는 경우는 크기의 차이만큼 잘려나간다. 그래서 경우에 따라 '값손실(loss of data)'이 발생가능

반대로 작은 타입에서 큰 타입으로의 변환, 예를 들어서 byte타입(1 byte)의 값을 int타입(4 byte)으로
변환하는 경우는 저장공간의 부족으로 잘려나가는 일이 없으므로 값 손실이 발생하지 않는다.
그리고 나머지 빈공간은 0 또는 1로 채워진다.

원래의 값을 채우고 남은 빈공간은 0으로 채우는 게 보통이지만, 변환하려는 값이
음수인 경우에는 빈 공간을 1로 채운다. 
그 이유는 형변환 후에도 부호를 유지할 수 있도록 하기 위해서이다.

###  5.4 실수형 간의 형변환

실수형에서도 정수형처럼 작은 타입에서 큰 타입으로 변환하는 경우, 빈 공간을 0으로 채운다.
float타입의 값을 double타입으로 변환하는 경우, 지수(E)는 float의 기저인 127을 뺀 후
double의 기저인 1023을 더해서 변환하고, 가수(M)는 float의 가수 23자리를 채우고
남은 자리를 0으로 채운다. 지수의 변화보다는 가수의 변화를 눈여겨본다.

float를 double로 형변환 하는경우 float의 가수를 채우고 남은 자리를 0으로 채운다.

반대로 double타입에서 float타입으로 변환하는 경우 지수(E)는 double의 기저인 1023을 뺸 후
float의 기저인 127을 더하고 가수(M)은 double의 가수 중 23자리만 저장되고 나머지는 버려진다.

한 가지 주의할 점은 형변환할 때 가수의 24번째 자리에서 반올림이 발생할 수 있다는 것이다.
24번째 자리의 값이 1이면, 반올림이 발생하여 23번쨰의 값이 1 증가한다.

그리고 float타입의 범위를 넘는 값을 float로 형변환하는 경우는 '±무한대' 또는 '±0'을 결과로 얻는다.

```java
double d = 1.0e100; //float의 최대값보다 큰 값을 d에 저장
float f = (float)d; //d의 값을 float로 형변환해서 f에 저장. f는 무한대가 된다.
double d = 1.e=50;  //float의 최소값보다 작은 값을 d에 저장
float f = (float)d; //f의 값은 0이 된다.
```

변수 f와 d에 같은 값을 저장했지만, 실제로 저장되는 값은 다르다.
변수 f에 저장된 값을 double타입으로 형변환해도 값은 그대로이다.

float 과 double 형변환시

같은 값을 저장해도 float와 double의 정밀도 차이때문에 서로 다른 값이 저장된다.

 그리고 저장할때 이미 값이 달라졌기 떄문에, 형변환을 해도 값이 같아지지 않는다

## 5.5 정수형과 실수형 간의 형변환

정수형과 실수형은 저장형식이 완전히 다르기 때문에 정수형간의 변환처럼
간단히 값을 채우고 자르는 식으로 할 수 없다. 좀더 복잡한 변환과정을 거쳐야한다.

정수형을 실수형으로 변환

```java
int : 1 + 31 = 32 (4 byte)
float: 1 + 8 + 23 + 32 (4 byte)
```



정수는 소수점이하의 값이 없으므로 비교적 변환이 간단하다. 
그저 정수를 2진수로 변환한 다음 정규화를 거쳐 실수의 저장형식으로 저장될 뿐이다.
이 과정은 이미 실수형의 저장형식에서 설명했으므로 생략한다

실수형은 정수형보다 훨씬 큰 저장범위를 갖기 떄문에, 정수형을 실수형으로 변환하는 것은
별 무리가 없다. 정수를 2진수로 변환한 다음에 정규화해서 실수의 저장형식에 맞게 저장할 뿐이다.
한 가지 주의할 점은 실수형의 정밀도의 제한으로 인한 오차가 발생할 수 있다는 것이다.
예를 들어 int의 최대값은 약 20억으로 최대 10자리의 정밀도를 요구한다.
그러나 float는 10진수로 약 7자리의 정밀도만을 제공하므로, int를 float로 변환할 때 
정밀도의 차이에 의한 오차가 발생할 수 있다. 그래서 10진수로 8자리 이상의 값을 실수형으로
변환할 때는 float가 아닌 double로 형변환해야 오차가 발생하지 않을 것이다.

```java
8자리이상의 정수값을 실수형으로 변환할 떄는 double 로 형변환
```

### 실수형을 정수형으로 변환

실수형을 정수형으로 변환하면, 실수형의 소수점이하 값은 버려진다.
정수형의 표현 형식으로 소수점 이하의 값은 표현할 수 없기 때문이다.
예를 들어 float타입의 상수 9.1234567f를 int타입으로 형변환 하면 9가 된다.

그래서 실수형을 정수형으로 형변환할 때 반올림이 발생하지 않는다.
예를들어, 실수 1.666을 int로 형변환하면, 1이 된다.

```java
1.666 → 1 
    (int)형변환
```

만일 실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우에는
정수의 오버플로우가 발생한 결과를 얻는다.

### 5.6 자동 형변환

서로 다른 타입간의 대입이나 연산을 할 떄, 형변환으로 타입을 일치시키는 것이 원칙이다.
하지만, 경우에 따라 편의상의 이유로 형변환을 생략할 수 있다.
그렇다고 해서 형변환이 이루어지지 않는 것은 아니고, 컴파일러가 생략된 형변환을 자동적으로 추가한다.

```java
float f =1234; // 형변환의 생략 float f = (float)1234; 와 같음.	
```

위의 문장에서 우변은 int타입의 상수이고, 이값을 저장하려는 번수의 타입은 float이다.
서로 타입이 달라서 형변환이 필요하지만 편의상 생략하였다.
float ㄴ타입의 변수는 1234라는 값을 저장하는데 아무런 문제가 없기떄문이다.
그러나 다음과 같이 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면
에러가 발생한다.

```java
byte b = 1000; //에러. byte의 범위 (-128~127)를 넘는 값을 저장.
```

에러 메시지는 'incompatible type: possible lossy conversion from int to byte'인데, 앞서 배운 것과 같이
큰 타입에서 작은 타입으로의 형변환은 값 손실이 발생할 수 있다는 뜻이다.
그러나 다음과 같이 명시적으로 형변환 해줬을 경우, 형변환이 프로그래머의 실수가 아닌
의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.

```java
char ch = (char)1000; //명시적 형변환. 에러가 발생하지 않는다.
```

또 다른 예로 다음과 같은 계산식에서 자주 형변환이 생략되는데, 서로 다른 두 타입의 연산에서는 먼저 타입을 일치시킨 다음에 연산을 수행해야 하므로, 연산과정에서 형변환이 자동적으로 이루어진다.

```java
int i = 3;
double b = 1.0 + i; //double d = 1.0 + (double) i; 에서 형변환이 생략됨
```

서로 다른 두 타입간의 덧셈에서는 두 타입 중 표헌범위가 더 넓은 타입으로 형변환하여 타입을 일치시킨 다음에
연산을 수행한다. 그렇게 하는 것이 값손실의 위험이 더 적어서 올바른 결과를 얻을 확률이 높기 때문이다.

이처럼 연산과정에서 자동적으로 발생하는 형변환을 '산술 변환'이라고 한다.

#### 자동 형변환의 규칙

형변환을 하는 이유는 주로 서로 다른 두 타입을 일치시키기 위해서 인데, 형변환을 생략하면
컴파일러가 알아서 자동적으로 형변환을 한다고 했다. 그러면 컴파일러는 어떤 판단기준으로 타입을 일치시킬까?

```java
기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.
```

표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 
표현범위가 더 넓은 쪽으로 형변환한다.

기본형의 자동 형변환이 가능한 방향은 다음과 같다.

```java
byte → short → int → long → float → double
       char  
```

왼쪽에서 오른쪽으로의 변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 되며, 그 반대 방향으로의 변환은 반드시 형변환 연산자를 써줘야한다.
보통 자료형의 크기가 큰 것일수록 값의 표현범위가 크기 마련이지만,
실수형은 정수형과 값을 표현하는 방식이 다르기 때문에 같은 크기일지라도 실수형이 정수형보다
훨씬 더 큼 표현 범위를 갖기 때문에 float와 double이 같은 크기인 int 와 long보다 오른쪽에 위치한다.
|참고| 정수형을 실수형으로 형변환하는 경우, 정밀도의 한계로 인한 오차가 발생할 수 있다.

char와 short은 둘 다 2byte의 크기로 크기가 같지만,  
서로 범위가 달라서 둘 중 어느 쪽으로의 형변환도 값 손실이 발생할 수 있으므로 자동 형변환이 수행될 수 없다.

```java
1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2. 기본형과 참조형은 서로 형변환할 수 없다.
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만,
   값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.
   
```

---

## Chapter 03. 연산자(operator)

1. ### 연산자(operator)

   연산자는 '연산을 수행하는 기호'를 말한다. 예를 들어 '+'기호는 덧셈 연산을 수행하며,
   '덧셈 연산자'라고 한다. 자바에서는 사칙연산(+,-,*,/)을 비롯해서 다양한 연산자들을 제공한다.
   처음에는 배워야할 연산자가 많아보이지만 자주 쓰이는 것들을 
   중심으로 하나씩 배워나가면 쉽게 익숙해질것이다.

### 1.1 연산자와 피연산자

연산자가 연산을 수행하려면 반드시 연산의 대상이 있어야하는데, 이것을 '피연산자(operand)'라고 한다.
피연산자로 상수, 변수 또는 식 등을 사용할 수 있다.

```java
연산자(operator) 연산을 수행하는 기호 (+,-,*,/ 등)
피연산자(operand) 연산자의 작업 대상(변수,상수,리터럴,수식)
```

다음과 같이 'x +3'이라는 식이 있을떄, '+'는 두 피연산자를 더해서 그 결과를 반환하는 덧셈 연산자이고,
변수 x와 상수3은 이 연산자의 피 연산자 이다.

```java
x + 3
//+는 연산자  , x 와 3은 피연산자
```

이처럼 덧셈연산자 '+'는 두 값을 더한 결과를 반환하므로, 두 개의 피연산자를 필요로 한다. 
대부분의 연산자는 이처럼 두 개의 피연산자를 필요로 하며, 
하나 또는 세 개의 피연산자를 필요로 하는 연산자도 있다. 
연산자는 피연산자로 연산을 수행하고  나면 항상 결과값을 반환한다. 
예를 들어 x의 값이 5일 때, 덧셈연산 'x + 3'의 결과값은 8이 된다.

### 1.2 식 과 대입연산자

연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것을 '식(expression)'이라고 한다.
그리고 식을 계산하여 결과를 얻는 것을 '식을 평가(evaluation)한다'고 한다. 
하나의 식을 평가(계산)하면, 단 하나의 결과를 얻는다. 만일 x의 값이 5라면, 아래의 식을 평가한 결과는 23이 된다.

```java
4 * x + 3   // = 23
```

작성한 식을 프로그램에 포함시키려면, 식의 끝네 ';' 를 붙여서 문장으로 만들어야 한다.

```java
4 * x + 3; //문장 (statement)
```

예를 들어 변수 x의 값이 5일 때, 위의 문장은 다음과 같은 과정으로 처리된다.

```ava
  y = 4 * x + 3;
→ y = 4 * 5 + 3;
→ y = 23; //식의 평가결과가 변수 y에 저장된다.
```

ㅡ 다음에는 변수 y에 저장된 값을 다른곳에 사용하거나 화면에 출력함으로써 의미있는 결과를 얻을 수 있다.

```java
y = 4 * x + 3;
System.out.println(y); // 변수 y의 값을 화면에 출력
```

만일 식의 평가결과를 출력하기만 원할 뿐, 이값을 다른 곳에 사용하지 않을 것이라면 
다음과 같이 변수에 저장하지 않고 println메서드의 괄호() 안에 직접 식을 써도 된다.

```java
  System.out.println(4 * x + 3);
→ System.out.println(23); //23이 화면에 출력된다.
```

### 1.3 연산자의 종류

배워야할 연산자의 개수가 많아서 부담스러울수 있는데, 기능이 비슷한 것들끼리 묶어놓고 보면 몇 종류 안된다.

|    종류     |          연산자          |                     설명                     |
| :---------: | :----------------------: | :------------------------------------------: |
| 산술 연산자 |     + - * / % << >>      |     사칙 연산(+,-,*,/)과 나머지 연산(%)      |
| 비교 연산자 |   >  <  >=  <=  ==  !=   |         크고 작음과 같고 다름을 비교         |
| 논리 연산자 | &&  \|\|  !  &  \|  ^  ~ | '그리고 (AND)'와 또는 (OR)' 으로 조건을 연결 |
| 대입 연산자 |            =             |           우변의 값을 좌변에 저장            |
|    기타     |  (type)   ?: instanceof  | 형변환 연산자, 삼항 연산자, instanceof연산자 |

|참고| (type)은 '형변환 연산자'를 의미한다.

연산자는 위의 표에서 알 수 있는 것처럼, 크게 산술, 비교, 논리, 대입 4가지로 나눌 수 있다.
산술, 비교, 대입 연산자는 이미 알고 있는 것들이고, 논리 연산자도 쉽게 이해가 될 것이다.

#### 피연산자의 개수에 의한 분류

피연산자의 개수로 연산자를 분류하기도 하는데, 
피연산자의 개수가 하나면 '단항 연산자', 두 개면 '이항 연산자',세 개면'삼항 연산자'라고 부른다. 대부분의 연산자는
'이상 연산자'이고, 삼항 연산자는 오직 '? :'하나 뿐이다.

```java
-3-5
부호연산자- 3 뺼셈 연산자- 5
```

부호 연산자'는 단항 연산자로 피연산자가 '3' 한 개 뿐이지만,
'뺄셈 연산자' 는 이항 연산자로 피연산자가 '-3'과 '5' 두 개이다.

이처럼 연산자를 기능별, 피연산자의 개수별로 나누어 분류하는 것은 
곧이어 배우게 될 '연산자의 우선순위'때문이기도 하다. 연산자마다 우선순위가 다르지만, 같은 종류의 연산자들은
우선순위가 비슷하기 때문에 각 종류별로 우선순위를 외우면 기억하기 더 쉽다.

### 1.4 연산자의 우선순위와 결합규칙

식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.
곱셉과 나눗셈( *, / )은 덧셈과 뺄셈(+ , -)보다 우선순위가 높다는 것은 이미 수학에서 배워서 알고 있을 것이다.
그래서 아래의 식은 '3 * 4 ' 가 먼저 계산된 다음, 그 결과에 5를 더해서 17을 결과로 얻는다.

```java
  5 + 3 * 4
=>5 + 12
=>17
```

이처럼 연산자의 우선순위는 대부분 상식적인 선에서 해결된다. 
아래의 표를 통해 이 사실을 한번 확인해보자.

|         식          |                             설명                             |
| :-----------------: | :----------------------------------------------------------: |
|       -x + 3        | 단항 연산자가 이항 연산자보다 우선순위가 높다. 그래서 x의 부호를 바꾼 다음 덧셈이 수행된다.<br />여기서 '-' 는 뺄셈 연산자가 아니라 부호 연산자이다. |
|      x + 3 * y      | 곱셈과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높다.<br />그래서 '3 * y'가 먼저 계산된다. |
|   x + 3 > y  - 2    | 비교 연산자 (>)보다 산술 연산자 '+'와 '-'가 먼저 수행된다.<br />그래서 'x + 3'과 'y - 2'가 먼저 계산된 다음에 '>'가 수행된다. |
|   x > 3 && x < 5    | 논리 연산자'&&'보다 비교 연산자가 먼저 수행된다.<br />그래서 'x > 3와 'x < 5' 가 먼저 계산된 다음 '&&' 가 수행된다.<br />식의 의미는 'x가 3보다 크고 5보다 작다' 이다. |
| result = x + y * 3; | 대입 연산자는 연산자 중에서 제일 우선순위가 낮다.<br />그래서 우변의 최종 연산결과가 변수 result에 저장된다. |

▲ 연산자 우선순위의 예와 설명

위에서 설명을 가린 채로 왼쪽의 식만 보고 어떤 순서로 연산이 수행될지 생각해보자. 그리 어렵지 않게
연산순서를 알아낼 수 있을 것이다. 실제 프로그래밍에서 사용되는 대부분의 식은 이처럼 상식적으로
판단이 가능한 수준이다.
상식만으로 판단하기 쉽지 않은 우선순위 몇 가지를 아래의 표에 정리하였다.
아직 배우지 앟은 연산자들이니까 지금은 가볍게 보고 이번 장을 다 배운 후에 다시 확인하자

|            식            |                             설명                             |
| :----------------------: | :----------------------------------------------------------: |
|        x << 2 + 1        | 쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다.<br />그래서 왼쪽의 식은 'x << (2+1)'과 같다. |
|     data & 0xFF == 0     | 비트 연산자 (&)는 비교 연산자(==)보다 우선순위가 낮으므로<br />비교연산후에 비트연산이 수행된다. 그래서 왼쪽의 식은 'date & (0xFF == 0)'과 같다. |
| x < -1 \|\| x > 3 && < 5 | 논리 연산자 중에서 AND를 의미하는 '&'와 '&&'가 OR를 의미하는 '\|'와 '\|\|'보다<br />우선순위가 높다. 이처럼 수식에 AND와 OR가 함께 사용되는 경우는 다음과 같이<br />괄호를 사용해서 우선순위를 명확히 하는 것이 좋다.<br />x < -1 \|\| ( x > 3 && x < 5) |

우리가 알고있는 일반적인 수학 상식과 위에 정리된 내용정도면 연산자의 우선순위 문제는 해결된다. 
만일 우선순위가 확실하지 않다면, 먼저 계산되어야하는 부분을 괄호로 묶어주면 된다.
괄호 안의 계산식이 먼저 계산될 것이 확실하기 떄문이다.

|참고| 괄호는 연산자가 아니다. 연산자의 우선순위를 임의로 지정할 때 사용하는 기호일 뿐이다.

#### 연산자의 결합규칙

하나의 식에 같은 우선 순위의 연산자들이 여러 개 있는 경우, 어떤 순서로 연산을 수행할까?
우선순위가 같다고 해서 아무거나 먼저 처리하는 것은 아니고 나름대로의 규칙을 가지고 있는데, 
그 규칙을 '연산자의 결합규칙'이라고 한다.

연산자의 결합규칙은 연산자마다 다르지만, 대부분 왼쪽에서 오른쪽의 순서로 연산을 수행하고,
단항 연산자와 대입 연산자만 그 반대로, 오른쪽에서 왼쪽의 순서로, 연산을 수행한다.



```java
// (a) 연산자의 결합규칙이 왼쪽에서 오른쪽인 경우
3 + 4 - 5     
 7  -  5
    2

```

(a)에서 수식 '3 + 4 = 5'는 덧셈연산자'+'의 결합방향이 왼쪽에서 오른쪽이므로 
수식의 왼쪽에 있는 '3+ 4'를 먼저 계산하고, 그 다음에 '3 + 4'의 연산결과인 7 과 5의 뺄셈을 수행한다.

```java
// (b) 연산자의 결합규칙이 오른쪽에서 왼쪽인 경우
x = y = 3
x  =  3 
   3 
```

(b)에서 대입 연산자는 연산자의 결합규칙이 오른쪽에서 왼쪽이므로 
수식 'x = y  = 3'에서 오른쪽의 대입연산자부터 처리한다. 따라서 'y = 3'이 먼저 수행되어서 y에 3이 저장되고
그 다음에 'x =3'이 수행되어 x에도 3이 저장된다.

|참고| 'x = y = 3;'은 'y=3;'과 'x=3;'을 하나의 문장으로 합쳐놓은 것으로 이해해도 좋다.

```java
x = y = 3
x = 3
3
```

앞서 모든 연산자는 연산결과를 갖는다고 했는데, 대입연산자도 예외는 아니다. 
대입연산자는 우변의 값을 좌변에 저장하고, 저장된 값을 연산결과로 반환한다. 
그래서 'y = 3'의 연산결과가 3이 되는 것이다.
지금까지 배운 연산자의 우선순위에 대해서 정리하면 다음과 같다.

```
1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.
```

이 내용만 잘 기억하고 있어도, 대부분의 연산자 우선순위 문제는 해결할 수 있을 것이다.

|    종류     | 결합규칙 |                          연산자                          | 우선순위 |
| :---------: | :------: | :------------------------------------------------------: | :------: |
| 단항 연산자 |    <     |              ++ , -- , + , - , ~ , ! (type)              |   높음   |
| 산술 연산자 |    >     |          * , / , % <br /> + , - <br /> <<  , >>          |          |
| 비교 연산자 |    >     |        < , > , <= , >= , instanceof<br />== , !=         |          |
| 논리 연산자 |    >     |          &<br />^<br />\|<br />&&<br />\|<br />          |          |
| 삼항 연산자 |    >     |                            ?:                            |          |
| 대입 연산자 |    <     | = , += , -= , *= , /=, %=<br /><<= , >>= , &= , ^= , \|= |   낮음   |

|주의| 단항연산자에 있는 '+'와 '-'는 부호연산자이고, '(type)'은 형변환 연산자이다.
|참고| instanceof는 객체의 타입을 확인하는데 사용되는 연산자이다. 객체지향개념||에서 설명한다.

시험에서는 연산자의 우선순위와 결합규칙으로 어려운 문제가 나올 수 있겠지만,
실제 프로그래밍에서는 앞서 정리한 3가지 내용과 몇 가지 예외적인 것들만 기억하는 것만으로도 충분하다.

### 1.5 산술 변환(usual arithmetic conversion)

이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면
연산 전에 형변환 연산자로 타입을 일치시켜야 한다. 예를 들어 int타입과 float타입을 덧셈하는 경우,
형변환 연산자를 사용해서 피연산자의 타입을 둘 다 int 또는 float로 일치시켜야 한다.

```java
int i = 10;
float f = 20.0f;
float result = f + (float)i; //형변환으로 두 피연산자의 타입을 일치
```

대부분의 경우, 두 피연산자의 타입 중에서 더 큰 타입으로 일치시키는데, 그이유는 작은 타입으로 형변환하면
원래의 값이 손실될 가능성이 있기 때문이다. 앞서 배운 것과 같이 작은 타입에서 큰 타입으로 형변환하는 경우,
자동적으로 형변환되므로 형변환 연산자를 생략할 수 있다.

```java
float result = f + i; // 큰 타입으로 형변환시, 형변환연산자 생략가능
```

이처럼 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 '산술 변환' 
또는 '일반 산술 변환'이라 하며, 이 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다.
'산술 변환'의 규칙은 다음과 같다.

```java
1. 두 피 연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
    long + int    >    long + long    >    long
   float + int    >    float + float   >   float
  double + float  >   double + double  >  double
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
    byte + short   >   int + int > int
    char + short   >   int + int > int
    
```

|참고| 모든 연산에서 '산술 변환'이 일어나지만, 쉬프트 연산자(<<,>>), 증감 연산자 (++ , --)는 예외이다.

첫 번째 규칙은 앞서 자동 형변환에서 배운 것처럼 피연산자의 값손실을 최소화하기 위한 것이고,
두 번째 규칙은 정수형의 기본 타입인 int가 가장 효율적으로 처리할 수 있는 타입이기 떄문에,
그리고 int 보다 작은 타입, 예를 들면 char나 short의 표현범위가 좁아서 
연산중에 오버플로우(overflow)가 발생할 가능성이 높기 떄문에 만들어진 것이다.

여기서 한 가지 주목해야할 점은 연산결과의 타입이다. 연산결과의 타입은 피연산자의 타입과 일치한다.
예를 들어 int와 int의 나눗셈 연산결과는 int이다. float와double과 같은 실수형이 아니기 떄문에
소수점 이하는 버려진다. 그래서 아래의 식 '5 나누기 2'의 결과가 2.5가 아닌 2이다.

```java
int / int > int
 5  /  2  >  2
```

위의 식에서 2.5라는 실수를 결과로 얻으려면, 피연산자 중 어느 한 쪽을 float와 같은 실수형으로 형변환해야 한다.
그러면, 다른 한쪽은 산술 변환의 첫 번째 규칙에 의해 자동적으로 형변환되어 두 피연산자 모두 실수형이 되고,
연산결과 역시 실수형의 값을 얻을 수 있다.

```java
int / (float)int   >   int / float   >   float / float   >  float
 5     (float)2    >   5  /  2.0f    >   5.0f  / 2.0f    >   2.5f
```

결국 산술 변환이란, 용어가 좀 거창하지만, 연산 직전에 발생하는 자동 형변환일 뿐이다.
아래의 두 가지 규칙만 잘 기억해두자.

```java
산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
    1.두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치).
    2.피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
```

## 2.단항 연산자

### 2.1 증감 연산자 ++ --

증감연산자는 피연산자에 저장된 값을 1 증가 또는 감소시킨다. 
증감연산자의 피연산자로 정수와 실수가 모두 가능하지만, 상수는 값을 변경할 수 없으므로 가능하지 않다.
앞서 형변환에서 설명한 것과 같이 대부분의 연산자는 피연산자의 값을 읽어서 연산에 사용할 뿐,
피연산자의 타입이나 값을 변경시키지 않는다. 오직 대입연산자와 증감연산자만 피연산자의 값을 변경한다.

|참고| 증감연산자는 일분 산술 변환에 의한 자동 형변환이 발생하지 않으며, 
          연산결과의 타입은 피연산자의 타입과 같다.

```java
증가 연산자(++) 피연산자의 값을 1 증가시킨다.
감소 연산자(--) 피연산자의 값을 1 감소시킨다.
```

일반적으로 단항 연산자는 피연산자의 왼쪽에 위치하지만, 증가 연산자 '++'와 감소 연산자 '--'는 양쪽 모두 가능하다.
피연산자의 왼쪽에 위치하면 '전위형(prefix)', 오른쪽에 위치하면 '후위형(postfix)'이라고 한다.
전위형과 후위형 모두 피연산자의 값을 1 증가 또는 감소시키지만, 
증감연산자가 수식이나 메서드 호출에 포함된 경우 전위형일 때와 후위형일 때의 결과가 다르다.

|  타입  |              설명              |  사용예   |
| :----: | :----------------------------: | :-------: |
| 전위형 | 값이 참조되기 전에 증가시킨다. | j = ++i;  |
| 후위형 |  값이 참조된 후에 증가시킨다.  | j = i++ ; |

그러나 '++i;'와 'i++;'처럼 증감연산자가 수식이나 메서드 호출에 포함되지 않고
독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 차이가 없다.

```java
++i;  // i의 값을 1 증가시킨다.
i++;  // 위의 문장과 차이가 없다.
```

i의 값을 증가시킨 후 출력할 때, 한번은 전위형(++i)을 사용했고, 또 한번은 후위형(i++)을 사용했다.
결과를 보면 두 번 모두 i의 초기값 5에서 1이 증가된 6이 출력됨을 알 수 있다.
이 경우에는 어떤 수식에 포함된 것이 아니라 단독적으로 사용된 것이기 때문에, 
증감연산자(++)를 피연산자의 왼쪽에 사용한 경우 (전위형, ++i)와 오른쪽에 사용한 경우 (후위형,i++)의 차이가 없다.
그러나 다른 수식에 포함되거나 메서드의 매개변수로 사용된 경우, 즉 단독으로 사용되지 않은 경우 
전위형(++i)과 후위형(i++)의 결과는 다르다. 다음의 예제를 보자

```java
class OperatorEx2 {
    public static void main(String[] args) {
        int i = 5; , j = 0;
        j = i++;
        System.out.println("j=i++; tlfgodgn, i=" + i +", j =" + j );
        int i = 5; , = j = 0;
        j = ++i;
        System.out.println("j=i++; tlfgodgn, i=" + i +", j =" + j );
     }
}
//  j = i++; 실행후, i = 6, j = 5
//  j = i++; 실행후, i = 6, j = 6 
```

실행결과를 보면 i의 값은 두 경우 모두 1이 증가되어 6이 되지만, j의 값은 그렇지 않다.
식을 계산하기 위해서는 식에 포함된 변수의 값을 읽어 와야 하는데, 
전위형은 변수(피연산자)의 값을 먼저 증가시킨 후에 변수의 값을 읽어오는 반면,
후위형은 변수의 값을 먼저 읽어온 후에 값을 증가시킨다.

전위형'j= ++i;'에서는 i의 값을 증가시킨 후에 읽어오므로 i의 값이 5에서 6으로 증가된 후에 이 값이 j에 저장되며,
후위형'j=i++;'에서는 i값인 5를 먼저 읽어온 다음에 i를 증가시키니까 j에 5가 저장된다.

증감 연산자가 포함된 식을 이해하기 어려울 때는 다음과 같이 증감 연산자를 따로 뗴어내면 이해하기 쉬워진다.

전위형의 경우 증감연산자를 식의 이전으로,

```java
j = ++i; //전위형은

++i;    //증가 후에
j = i;  //참조하여 대입
```

후위형의 경우 증감연산자를 식의 이후로 뗴어내면 된다.

```java
j = i++; // 후위형

j = i;   // 참조하여 대입 후에
i++;     // 증가
```

증감연산자를 사용하면 코드가 간결해지지만, 지나치면 코드가 복잡해서 이해하기 어려워지기도 한다.
예를 들어 x의 값이 5일 떄, 아래 식이 수행된 후의 x의 값은 얼마일까?

```java
x = x++ - ++x; //x의 값은 -1? -2?
```

생각보다 쉽게 답을 내기 어려울 것이다. 실제 프로그래밍에서는 이러한 코드를 작성할 일이 없고,
이렇게 작성하는 것은 바람직하지 않다. 하나의 식에서 증감연산자의 사용을 최소화하고,
식에 두 번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야 한다.
감소 연산자(--)는 피연산자의 값을 1 감소시킨다는 것만 빼면 증가 연산자와 동일하다.

### 2.2 부호 연산자 + -

부호 연산자'-'는 피연산자의 부호를 반대로 변경한 결과를 반환한다. 
피연산자가 음수면 양수, 양수면 음수가 연산의 결과가 된다. 부호연산자'+'는 하는일이 없으며,
쓰이는 경우도 거의 없다. 부호연산자'-'가 있으니까 형식적으로 '+'를 추가해 놓은 것뿐이다.
부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용할 수 있다.

|참고| 부호연산자는 덧셈,뺄셈연산자와 같은 기호를 쓰지만 다른 연산자이다. 기호는 같아도
          피연산자의 개수가 달라서 구별이 가능하다.

```java
class OperatorEx4 {
    public static void main(String[] args) {
        int i = -10;
        i = +i;
        System.out.println(i);
        
        int i = -10;
        i = -i;
        System.out.println(i);
    }  
}
```

실행결과 

-10
10

지금까지 소개한 연산자외에도 '단항 연산자'가 더 있지만, 편의상 관련된 이항연산자와 함께 놓았다.
논리부정 연산자 '!'는 5.1 논리 연산자'에서 , 비트전환 연산자 '~'는 5.2 비트연산자에서 설명한다.

### 3.산술 연산자

산술 연산자에는 사칙 연산자(+, -, *, /)와 나머지 연산자(%)가 있다. 
사칙연산은 일상생활에서 자주 사용하는 익숙한 것이라 그리 어렵지 않을 것이다. 다만 몇 가지 주의할 사항들이
있는데, 그 것들을 중심으로 설명할 것이다.

### 3.1 사칙 연산자 + - * / 

사칙 연산자, 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/)은 아마도 프로그래밍에 가장 많이 사용되는 연산자들 일 것이다.
여러분들이 이미 알고 있는 것처럼 곱셈(*), 나눗셈(/), 나머지(%) 연산자가 덧셈(+), 뺄셈(-)연산자보다
우선순위가 높으므로 먼저 처리된다. 그리고 피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다. 
만일 0으로 나눈다면, 컴파일은 정상적으로 되지만 
실행 시에 에러(ArithmeticException)가 발생할 것이다.

```java
public class Test1 {
  public static void main(String[] args) {
byte a = 10;
byte b = 20;
byte c = a + b;
System.out.println(c);
  }
}     //컴파일 에러
```

a와 b는 모두 int형보다 작은 byte형이기 때문에 연산자 '+'는 
이 두 개의 피연산자들의 자료형을 int형으로 변환한 다음 연산(덧셈)을 수행한다.
그래서 'a+b'의 연산결과는 byte형이 아닌 int형(4 byte)인 것이다. 4 byte의 값을 1byte의 변수에 형변환없이
저장하려고 했기 떄문에 에러가 발생하는 것이다.
크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동으로 형변환(type conversion, casting)되지만,
반대로 큰 자료형의 값을 작은 자료형의 변수에 저장하려면 
명시적으로 형변환 연산자를 사용해서 아래처럼 변환해주어야 한다.

```java
byte a = 10;
byte b = 20;
byte c = (byte)(a+b);
System.out.println(c);
```

```java
public class Test1 {
  public static void main(String[] args) {
byte a = 10;
byte b = 20;
byte c = (byte)(a*b);
System.out.println(c);
  }
}
```

이 예제를 실행하면 44가 화면에 출력된다. '10 * 30'의 결과는 300이지만, 형변환(캐스팅,casting)에서 배운 것처럼,
큰 자료형에서 작은 자료형으로 변환하면 데이터의 손실이 발생하므로 값이 바뀔 수 있다.
300은 byte형의 범위를 넘기 때문에 byte형으로 변환하면 데이터 손실이 발생하여 
결국 44가 byte형 변수 c에 저장된다. 

byte형(1 byte)에서 int형 (4 byte)으로 변환하는 것은 2진수 8자리에서 32자리로 변환하는 것이기 떄문에
자료 손실이 일어나지 않는다. 원래 8자리는 그대로 보존하고 나머지는 모두 0으로 채운다.
음수인 경우에는 부호를 유지하기 위해 0 대신 1로 채운다.
반대로 int형을 byte형으로 변환하는 경우 앞의 24자리를 없애고 하위 8자리 (1byte)만을 보존한다.
저장된 값이 10인 경우 값이 작아서 상위 24자리를 잘라내도 원래 값을 유지하는데 지장이 없지만,
byte형의 범위인 '-128~127'의 범위를 넘는 int형의 값을 byte형으로 변환하면, 원래의 값이 보존되지 않고
byte형의 범위 중 한 값을 가지게 된다. 이러한 값 손실을 예방하기 위해서는 충분히 큰 자료형을 사용해야 한다.

```java
class Test{
    public static void main(String[] args) {
        int a = 1_000_000; // 1,000,000 1백만
        int b = 2_000_000; // 2,000,000 2백만
        
        long c = a * b; //a * b = 2,000,000,000,000?
    }
}
```

식 'a * b'의 결과 값을 담는 변수 c의 자료형이 long타입(8byte)이기 때문에 값을 저장하기에 충분하므로 
"200000000000"이 출력될 것 같지만, 결과는 전혀 다른 값이 출력된다.
그 이유는 int타입과 int타입의 연산결과는 int타입이기 떄문이다.
'a * b'의 결과가 이미 int타입의 값(-1454759936)이므로 long형으로 자동 형변환되어도 값은 변하지 않는다.

```java
   long c = a * b;
 > long c = 1000000 * 200000;
 > long c = -1454759936;
```

올바른 결과를 얻으려면 아래와 같이 변수 a 또는 b의 타입을 'long'으로 형변환해야 한다.

```java
  long c = (long)a * b;
→ long c = (long)100000 * 200000;
→ long c = 100000L * 200000;
→ long c = 100000L * 200000L;
→ long c = 2000000000000L;
```



```java
class Test{
    public static void main(String[] args) {
        long a = 1_000_000 * 1_000_000;
        long b = 1_000_000 * 1_000_000L;
        
    }
}
```

이 예제는 1000000 * 1000000 의 결과가 -727379968이라는 결과가 출력되었다. 
그 이유는 int타입과 int타입의 연산결과는 int타입인데, 
연산결과가 int타입의 최대값인 약 2 x 10을 넘으므로 오버플로우(overflow)가 발생했기 때문이다.
이미 오버플로우가 발생한 값을 아무리 long타입의 변수에 저장을 해도 소용이 없다.

그러나 '1000000 * 10000000L'은 int타입과 long타입의 연산이기 때문에 그 결과가 long타입이다.
long타입은 연산결과인 10^12를 저장할 수 있는 타입이므로 올바른 결과를 얻을 수 있다.

```java
int a = 1000000;
int result1 = a * a / a;
int result2 = a / a * a;
//result1 = -727
//result2 = 1000000
```

1,000,000에 1,000,000을 먼저 곱한 후에 나누는 것과 먼저 나눈 후에 곱하는 것의 연산결과가 다르다는 것을
알 수 있다. 먼저 곱하는 경우 int의 범위를 넘어서기 때문에 예상했던 것과 다른 결과가 나왔다.

이처럼 같은 의미의 식이라도 연산의 순서에 따라서 다른 결과를 얻을 수 있다는 것에 주의하자.

```java
class Test {
    public static void main(String[] args) {
        char a = 'a';
        char d = 'd';
        char zero = '0';
        char two = '2';
        System.out.printf("'%c' - '%c' = %d\n", d, a, d - a); //'d' -'a' = 3
        System.out.printf("'%c' - '%c' = %d\n", two, zero, two - zero);
        System.out.printf("'%c' = '%d\n", a, (int)a);
        System.out.printf("'%c' = '%d\n", d, (int)d);
        System.out.printf("'%c' = '%d\n", zero, (int)zero);
        System.out.printf("'%c' = '%d\n", two, (int)two);
    }
}
```

실행 결과

```
'd' - 'a' = 3
'2' - '0' = 2
'a' = 97
'd' = 100
'0' = 48
'2' = 50
```

사칙연산의 피연산자로 숫자뿐만 아니라 문자도 가능하다.
문자는 실제로 해당 문자의 유니코드(부호없는 정수)로 바뀌어 저장되므로 
문자간의 사칙연산은 정수간의 연산과 동일하다. 주로 문자간의 뺄셈을 하는 경우가 대부분이며,
문자'2'를 숫자로 변환하려면 다음과 같이 문자 '0'을 뺴주면 된다.

```java
'2' - '0' → 50 - 48 → 2
```

문자 '2'의 유니코드는 50이고, 문자'0'은 48이므로, 두 문자간의 뺄셈은 2를 결과로 얻는다.
아래의 표는 유니코드의 일부인데, '0' ~ '9'까지의 문자가 연속적으로 배치되어 있는 것을 알 수 있다.
그렇기 떄문에 해당 문자에서 '0'을 뺴주면 숫자로 변환되는 것이다.

| 문자 | 코드 | 문자 | 코드 | 문자 | 코드 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 48   | A    | 65   | a    | 97   |
| 1    | 49   | B    | 66   | b    | 98   |
| 2    | 50   | C    | 67   | c    | 99   |
| 3    | 51   | D    | 68   | d    | 100  |
| 4    | 52   | E    | 69   | e    | 101  |
| 5    | 53   | ...  | ..   | ...  | ...  |
| 6    | 54   | X    | 88   | x    | 120  |
| 7    | 55   | Y    | 89   | y    | 121  |
| 8    | 56   | Z    | 90   | z    | 122  |

'A'~ 'Z'와 'a'~'z' 역시 연속적으로 배치되어 있기 때문에, 문자 'd'에서 문자'a'를 빼면 다음과 같이 처리된다.

```java
'd' - 'a' → 100 - 97 → 3
```

```JAVA
class test {
    public static void main(String[] args) {
      char c1 = 'a'; //c1에는 문자 'a'의 코드값인 97이 저장된다. 
      char c2 = c1;  //c1에 저장되어 있는 값이 c2에 저장된다.
      char c3 = ' '; //c3를 공백으로 초기화 한다.
      int i c1 + 1;  //'a' + 1 → 97+1 → 98
      c3 = (char)(c1 + 1);
      c2++;
      c2++;
        
      System.out.println("i=" + i);
      System.out.println("c2=" + c2);
      System.out.println("c3=" + c3);
       
    }
}
```

실행결과

```java
i = 98
c2 = c
c3 = b
```

'c1 + 1'을 계산할 때, c1이 char형이므로 int형으로 변환한 후 덧셈연살을 수행하게 된다.
c1에 저장되어 있는 코드값이 변환되어 int형 값이 되는 것이다. 따라서 'c1 + 1'은 '97 + 1'이 되고
결과적으로 int형 변수 i에는 98이 저장된다.
'c2++'은 형변환없이 c2에 저장되어 있는 값을 1 증가시키므로, 
예제에서는 원래 저장 되어 있던 값인 97이 1씩 두 번 증가되어 99가 된다.
코드값이 10진수로 99인 문자는 'c'이다. 따라서 c2를 출력하면, 'c'가 화면에 나타나는 것이다.

|참고| c2++; 대신에 c2=c2+1;을 사용하면 에러가 발생할 것이다. 
          c2+1의 연산결과는 int형이며, 그 결과를 다시 c2에 담으려면 형변환 연산자를 사용하여 char형으로 
          형변환해야 하기 때문이다.

```java
class Test {
    public static void main(String[] args) {
        char c1 = 'a';
        
        //char c2 = c1 + 1; //컴파일에러
        char c2 = 'a'+ 1; //컴파일 에러없음
        System.out.println(c2);
    }
}
```

실행결과  

```java
b
```

이 예제를 컴파일 하면 오류가 발생하지 않고 실행도 올바른 결과를 얻는다. 
덧셈 연산자와 같은 이항 연산자는 int보다 작은 타입의 피연산자를 int로 자동 형변환한다고 배웠는데,
어째서 아래의 코드처럼 형변환을 해주지 않고도 문제가 없는 것일까?

```java
char c2 = (char)('a' + 1);
```

그것은 바로 'a' + 1이 리터럴 간의 연산이기 때문이다. 상수 또는 리터럴 간의 연산은 실행 과정동안
변하는 값이 아니기 떄문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다
컴파일러가 미리 덧셈연산을 수행하기 때문에 실행 시에는 덧셈 연산이 수행되지 않는다.
그저 덧셈연산결과인 문자 'b'를 변수 c2에 저장할 뿐이다.

|                컴파일 전의 코드                 |           컴파일 후의 코드           |
| :---------------------------------------------: | :----------------------------------: |
| char c2 = 'a' + 1;<br />int sec = 60 * 60 * 24; | char c2 = 'b';<br />int sec = 86400; |

▲컴파일러에 의해서 최적화된 코드의 비교

그러나 수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에
아래의 오른쪽 코드와 같이 형변환을 해주어야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

```java
char c2 = c1 + 1;  →   char c2 = (char)(c1+1);
```

일부러 뻔 한 리터럴 연산을 풀어쓸 필요는 없지만, 코드의 가독성과 유지보수를 위해서 그렇게 하는 경우가 있다. 
int타입의 변수 sec에 하루(day)를 초(second)단위로 변환한 값을 저장하는 코드를 보면,'86400'이라는 값보다는
'60 * 60 * 24' 와 같이 적어주는 것이 이해하기도 쉽고 오류가 발생할 여지가 적다.
나중에 반나절(12시간)로 값을 변경해야 한다면 계산할 필요없이 '60 * 60 * 12'로 변경하면 되기 때문이다.
이렇게 풀어써도 결국 컴파일러에 의해서 미리 계산되기 때문에 실행 시의 성능차이는 없다.

```java
class Test {
    public static void main(String[] args) {
        char c = 'a';
        for (int i = 0; i < 26; i++) {  //블럭 {}안의 문장을 26번 반복한다.
            System.out.print(c++);      //'a'부터 26개의 문자를 출력한다.
        }
        System.out.println(); //줄바꿈을 한다.
        
        c = 'A';
        
        for (int i = 0; i < 26; i++) { //블럭 {}안의 문장을 26번 반복한다.
            System.out.print(c++);     //'A'부터 26개의 문자를 출력한다.
        }
        System.out.println();
        
        c = '0';
        for (int i = 0; i <10; i++) { //블럭 {}안의 문장을 10번 반복한다.
            System.out.print(c++);    //'0'부터 10개의 문자를 출력한다.
        }
        System.out.println();
    }
}
```

실행결과

```java
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQUSTUVWXYZ
0123456789
```

|참고| println 메서드는 값을 출력하고 줄을 바꾸지만, print메서드는 줄을 바꾸지 않고 출력한다. 
         매개변수없이 println메서드를 호출하면, 아무 것도 출력하지 않고 다음 줄의 처음으로 출력위치를 이동시킨다.

위의 예제를 실행하면, 문자 a부터 시작해서 26개의 문자를 출력하고, 또 문자 A부터 시작해서 26개의 문자,
0부터 9까지 10개의 문자를 출력한다. 소문자 a부터 z까지, 그리고 대문자 A부터 Z까지, 숫자 0부터 9까지
연속적으로 코드가 지정되어 있기 때문에 이런 결과가 나타난다.
문자 a의 코드값은 10진수로 97, b의 코드값은 98, c의 코드값은 99 , ... , z의 코드값은 122이며,
문자 A의 코드값은 10진수로 65, B의 코드 값은 66, C의 코드값은 67, ... , Z의 코드값은 90이다.
그리고 문자 0의 코드값은 10진수로 48이다.
이 사실을 이용하면 대문자를 소문자로 소문자를 대문자로 변환하는 프로그램을 작성할 수 있다.

```java
class Test {
    public static void main(String[] args) {
        char lowerCase = 'a';
        char upperCase = (char)(lowerCase - 32);
        System.out.println(upperCase);
    }
}
```

실행결과 

```java
A
```

소문자를 대문자로 변경하려면, 대문자 A가 소문자 a보다 코드값이 32가 적으므로 
소문자 a의 코드값에서 32를 빼면 되고, 반대로 대문자를 소문자로 변환하려면 
대문자의 코드값에 32를 더해주면 된다.

|참고| char형과 int형 간의 뺄셈연산 결과는 int형이므로, 연산 후 char형으로 다시 형변환해야 한다는 것을 잊지 말자.

```java
class Test {
    public static void main(String[] args) {
        float pi = 3.141592f;
        float shortPi = (int)(pi * 1000) / 1000f;
        System.out.println(shortPi);
    }
}
```

int형 간의 나눗셈 'int / int'를 수행하면 결과가 float나 double이 아닌 int임에 주의하라.
그리고 나눗셈의 결과를 반올림을 하는 것이 아니라 버린다는 점도 꼭 기억하자. 
예를 들어 '3 / 2'의 결과는 1.5 또는 2가 아니라 1이다.
이 예제는 나눗셈 연산자의 이러한 성질을 이용해서 
실수형 변수 pi의 값을 소수점 셋째 자리까지만 빼내는 방법을 보여 준다.

```java
(int)(pi * 1000) / 1000f;
```

위의 수식에서 제일 먼저 수행되는 것은 괄호 안의 'pi * 1000'이다. pi가 float이고 1000이 정수형이니까
연산의 결과는 float인 3141.592f가 된다.

```java
(int)(3141.592f) / 1000f;
```

그 다음으로는 단항연산자인 형변환 연산자의 형변환이 수행된다. 3141.592f를 int로 변환하면 3141을 얻는다.
소수점 이하는 반올림 없이 버려진다.

```java
3141 / 1000f;	
```

int와 float의 연산이므로, int가 float로 변환된 다음, float와 float의 연산이 수행된다.

```java
3141.0f / 1000f → 3.141f
```

float와 float의 나눗셈이므로 결과는 float인 3.141f가 된다.

|참고| 1000f는 1000.0f와 같다.

그렇다면 버림이 아닌 반올림이 되도록 하려면 어떻게 해야 할까? 
다음 예제가 그 방법을 알려준다.

```java
class Test {
    public static void main(String[] args) {
        double pi = 3.141592;
        double shortPi = (int)(pi * 1000 + 0.5) / 1000.0;
        
        System.out.println(shortPi);
    }
}
```

실행결과 

```java
3.142
```

이 예제는 소수점 넷째자리에서 반올림하는 방법을 보여준다. 
이전 예제와 다른 점은 반올림을 위해 0.5를 더해 준다는 것이다.

```java
(int)(pi * 1000 + 0.5) / 1000.0
```

위의 수식에서 제일 먼저 수행 되는 것은 괄호 안의 'pi * 1000'이다. pi가 double이고 1000이 정수형이니까
연산의 결과는 double인 3141.592가 된다. 그리고 여기에 0.5를 더하면 3142.092가 된다.

```java
 (int)(3141.592 + 0.5) / 1000.0
→(int)(3142.092) / 1000.0    
```

그 다음엔 형변환 연산자에 의해서 형변환되어 3142.092가 3142가 된다.

```java
3142 / 1000.0
```

int와 double의 연산이므로, int가 double로 변환한 다음, double과 double의 연산이 수행된다.

```java
3142.0 / 1000.0 → 3.142
```

double과 double의 나눗셈이므로 결과는 double인 3.142가 된다. 만일 1000.0이 아닌 1000으로 나누었다면,
3.142가 아닌 3을 결과로 얻었을 것이다.
Math.round()를 사용하면 좀 더 간단하 반올림할 수 있다. 다음의 예제는 이 메서드의 사용법을 알려준다.

```java
class Test {
    public static void main(String[] args) {
        double pi = 3.141592;
        double shortPi = Math.round(pi * 1000) / 1000.0;
        System.out.println(shortPi);
    }
}
```

실행결과

```java
3.142
```

이 예제의 결과는 pi의 값을 소수점 넷째 자리인 5에서 반올림을 해서 3.142가 출력되었다.
round메서드는 매개변수로 받은 값을 소수점 첫쨰자리에서 반올림을 하고 그 결과를 정수로 돌려주는 메서드이다.
그래 서 Math.round(3141.592)의 결과는 3142이다.

```java
  Math.round(pi * 1000) / 1000.0
→ Math.round(3.141592 * 1000) / 1000.0
→ Math.round(3142.592) / 1000.0
→ 3142 / 1000.0
→ 3.142
```

### 3.2 나머지 연산자 %

나머지 연산자는 왼쪽의 피연산자를 오른쪽 피연산자로 나무고 난 나머지 값을 결과로 반환하는 연산자이다.
그리고 나눗셈에서처럼 나누는수(오른쪽 피연산자)로 0을 사용할 수 없다는 점에 주의하자. 
나머지 연산자는 주로 짝수, 홀수 또는 배수 검사 등에 주로 사용된다.

```java
class Test {
    public static void main(String[] args) {
        int x = 10;
        int y = 8;
        
        System.out.printf("%d를 %d로 나누면, \n", x, y);
        System.out.printf("몫은 %d 이고, 나머지는 %d입니다", x / y, x % y);
    }
}
```

실행결과

```java
10을 8로 나누면, 몫은 1이고, 나머지는 2입니다.
```

나눗셈 연산자와 나머지 연산자를 이용해서 몫과 나머지를 구하는 예제이다.
간단한 예제라서 따로 설명하지 않아도 이해하는 데 어려움이 없을 것이다.

```java
class Test {
    public static void main(String[] args) {
        System.out.println(-10%8);
        System.out.println(10%-8);
        System.out.println(-10%-8);
    }
}
```

실행결과

```
-2
2
-2
```

나머지 연산자(%)는 나누는 수로 음수도 허용한다. 그러나 부호는 무시되므로 결과는
음수의 절대값으로 나눈 나머지와 결과가 같다.

```java
System.out.println(10 % 8); //10을 8로 나눈 나머지 2가 출력된다.
System.out.println(10 %-8); //위와 같은 결과를 얻는다.
```

그냥 피연산자의 부호를 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자(나눠지는 수)의 부호를 붙이면 된다.

### 4.비교 연산자

비교 연산자는 두 피연산자를 비교하는 데 사용되는 연산자다. 주로 조건문과 반복문의 조건식에 사용되며,
연산결과는 오직 true와 false 둘 중의 하나이다.
비교 연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는
자료형의 범위가 큰 쪽으로 자동 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다는 점에 주의하자.

### 4.1 대소비교 연산자 < , > , <= , >= 

두 피연산자의 값의 크기를 비교하는 연산자이다. 참이면 true를, 거짓이면 false를 결과로 반환한다.
기본형 중에는 boolean형을 제외한 나머지 자료형에 다 사용할 수 있지만
참조형에는 사용할 수 없다.

| 비교연산자 |                  연산결과                  |
| :--------: | :----------------------------------------: |
|     >      |     좌변 값이 크면, true 아니면 false      |
|     <      |    좌변 값이 작으면, true 아니면 false     |
|     >=     | 좌변 값이 크거나 같으면, true 아니면 false |
|     <=     | 좌변 값이 작거나 같으면, true 아니면 false |

▲ 대소비교연산자의 종류와 연산결과

### 4.2 등가비교 연산자 == !=

두 피연산자의 값이 같은지 또는 다른지를 비교하는 연산자이다. 
대소비교 연산자(<,>,<=,>=)와는 달리, 기본형은 물론 참조형,  즉 모든 자료형에 사용할 수 있다.
기본형의 경우 변수에 저장되어 있는 값이 같은지를 알 수 있고, 참조형의 경우 객체의 주소값을 저장하기 때문에
두 개의 피연산자(참조변수)가 같은 객체를 가리키고 있는지를 알 수 있다.
기본형과 참조형은 서로 형변환이 가능하지 않기 때문에 
등가비교 연산자(==,!=)로 기본형과 참조형을 비교할 수 없다.

| 비교연산자 |             연산결과              |
| :--------: | :-------------------------------: |
|     ==     | 두 값이 같으면, true 아니면 false |
|     !=     | 두 값이 다르면, true 아니면 false |

▲등가비교연산자의 종류와 연산결과

비교연산자는 수학기호와 유사한 기호와 의미를 가지고 있이므로 이해하는데 별 어려움이 없을 것이다.
한 가지 다른 점은 '두 값이 같다'는 의미로 '='가 아닌 '=='를 사용한다는 것인데,
'='는 이미 배운 것과 같이 변수에 값을 저장할 때 사용하는 '대입연산자' 이기 때문에
'=='로 두 값이 같은지 비교하는 연산자를 표현한다.

|주의| '>='와 같이 두 개의 기호로 이루어진 연산자는 '=>'와 같이 기호의 순서를 바꾸거나'>=' 와 같이 
          중간에 공백이 들어가서는 안 된다.

```java
class Test {
    public static void main(String[] args) {
        System.out.printf("10 == 10.0f / t %b\n", 10 == 10.0f);
        System.out.printf("'0' == 0    / t %b\n", '0' == 0);
        System.out.printf("'A' == 65   / t %b\n", 'A' == 65);
        System.out.printf("'A' > 'B'   / t %b\n", 'A' > 'B');
        System.out.printf("'A' +1 !='B'/ t %b\n", 'A'+1 != 'B');
    }
}
```

비교 연산자도 이항 연산자이므로 연산을 수행하기 전에 형변환을 통해 두 피연산자의 타입을 같게 맞춘 다음
피연산자를 비교한다. 10==10.0f에서 10은 int타입이고 10.0f는 float타입이므로, 10을 float로 변환한 다음에 비교한다.
두 값이 10.0f로 같으므로 결과로 true를 얻게된다.

```
  10 == 10.0f
→ 10.0f == 10.0f
→ true
```

문자 'A'의 유니코드는 10진수로 65이고, 'B'는 66, '0'은 48이므로 나머지 식들은 다음과 같은 과정으로 연산된다.

```2
  '0' == 0  → 48 == 0  →  false
  'A' == 65 → 65 == 65 →  true   
  'A' > 'B' → 65 > 66  →  false
  'A' + 1 != 'B'   →   65+1  != 66    →    66  !=  66     →     false
```

```java
class Test {
    public static void main(String[] args) {
        float f = 0.1f;
        double d = 0.1;
        double d2 = (double) f;
        
        System.out.printf("10.0 == 10.0f %b\n", 10.0 == 10.0f); // 10.0 == 10.0f true
        System.out.printf("0.1 == 0.1f  %b\n", 0.1 == 0.1f);    //0.1==0.1f  false
        System.out.printf("f = %19.17f\n", f);                  // f = 0.10000000149011612
        System.out.printf("d = %19.17f\n", d);                  // d = 0.10000000000000000
        System.out.printf("d2 = %19.17f\n", d2);                // d2= 0.10000000149011612
        System.out.printf("d == f %b\n", d==f);                 //d==f  false
        System.out.printf("d == d2 %b\n", d==d2);               //d==d2 false
        System.out.printf("d2 ==f %b\n", d2==f);                //d2==f true
        System.out.printf("(float)d==f %b\n",(float)d==f);      //(float)d==f true
    }
}
```

이 예제를 보고 다소 혼란스러울 것이다. '10.0 == 10.0f'는 true인데 '0.1==0.1f'는 false라니 이해하기 어렵다.
왜 이런 결과를 얻는 것일까? 
그것은 정수형과 달리 실수형은 근사값으로 저장되므로 오차가 발생할 수 있기 때문이다.
10.0f는 오차없이 저장할 수 있는 값이라서 double로 형변환해도 그대로 10.0이 되지만,
0.1f는 저장할 때 2진수로 변환하는 과정에서 오차가 발생한다. 
double타입의 상수인 0.1도 저장되는 과정에서 오차가 발생하지만, 
float타입의 리터럴인 0.1f보다 적은 오차로 저장된다.

```
float f = 0.1f;   // f에 0.10000000149011612로 저장된다.
double d = 0.1;   // d에 0.10000000000000001로 저장된다.
```

이미 앞서 배운 것처럼 float타입의 값을 double타입으로 형변환하면, 부호와 지수는 달라지지 않고
그저 가수의 빈자리를 0으로 채울 뿐이므로 0.1f를 double타입으로 형변환해도 그 값은 전혀 달라지지 않는다.
즉, float타입의 값을 정밀도가 더 높은 double타입으로 형변환했다고 해서 오차가 적어지는 것이 아니라는 얘기다.
|참고|지수부의 값도 달라진 것처럼 보이지만, float타입과 double타입의 기저(biad)의 차이에 의한 것일 뿐
달리지지 않았다.

그래서 식 'd==f' 가 연산되는 과정을 단계별로 살펴보면 다음과 같다. 최종결과는 false이다.
변수f를 double타입으로 형변환해도 값이 변하지 않았음에 주목하자.

```java
→ d == f
→ d == (double) f
→ 0.1000000000000001 == (double)0.10000000149011612
→ 0.1000000000000001 == 0.10000000149011612
→ false
```

마찬가지로 변수 d2에 변수 f의 값을 double로 형변환해서 저장해도, 직전에 설명한 것과 같이
f의 값이 그대로 d2에 저장된다. 그래서 ' d2 ==f '의 결과가 true가 되는 것이다.

```java
  double d2 = (double)f;
→ double d2 = (double)0.10000000149011612;
→ double d2 = 0.10000000149011612;

  d2 == f
→ 0.10000000149011612 == 0.10000000149011612
→ true
```

그러면 float타입의 값과 double타입의 값을 비교하려면 어떻게 해야 하는 걸까? 
double 타입의 값을 float타입으로 형변환한 다음에 비교해야 한다. 그래야만 올바른 결과를 얻을 수 있다.
또는, 어느 정도의 오차는 무시하고 두 타입의 값을 앞에서 몇 자리만 잘라서 비교할 수도 있다.

```java
  (float)d == f
→ (float) 0.10000000000000001 == 0.10000000149011612
→ 0.10000000149011612 == 0.10000000149011612
→ true
```

### 문자열의 비교

두 문자열을 비교할 때는, 비교 연산자 '=='대신 equals()라는 메서드를 사용해야 한다.
비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐이므로, 
문자열의 내용이 같은지 비교하기 위해서는 equals()를 사용하는 것이다. 
equals()는 비교하는 두 문자열이 같으면 true를, 다르면 false를 반환한다.

```java
String str = new String("abc");

//equals()는 두 문자열의 내용이 같으면 true, 다르면 false
boolean result = str.equals("abc"); //내용이 같으므로 result에 true가 저장됨
```

원래 String은 클래스이므로, 아래와 같이 new를 사용해서 객체를 생성해야한다.

```java
String str = new String("abc"); //String클래스의 객체를 생성
String str = "abc";             //위의 문장을 간단히 표현
```

그러나 특별히 String만 new를 사용하지 않고, 위와 같이 간단히 쓸 수 있게 허용한다. 
위 두 문장은 거의 같지만, 한 가지 차이점이 있는데, 
이에 대해서는 '9장 java.lang패키지와 유용한 클래스'에서 설명한다.
지금은 문자열을 비교할 때 비교 연산자가 아니라 equals()를 사용해야한다는 것만 알면 된다.

```java
class Test {
    public static void main(String[] args) {
        String str1 = "abc";
        String str2 = new String("abc");
        
        System.out.printf("\"abc\"abc\"   ? %b\n",  "abc"=="abc");
        System.out.printf(" str1==\"abc\" ? %b\n", "str1"=="abc");
        System.out.printf(" str2==\"abc\" ? %b\n", "str2"=="abc");
        System.out.printf("str1.equals(\"abc\")  ? %b\n", str1.equals("abc"));
         System.out.printf("str2.equals(\"abc\")  ? %b\n", str2.equals("abc"));
         System.out.printf("str2.equals(\"ABC\")  ? %b\n", str2.equals("ABC"));
         System.out.printf("str2.equalsIgnoreCase(\"ABC\")  ? %b\n", str2.equals("ABC"));
    }
}
```

실행결과

```java
"abc"=="abc" ? true
 str1=="abc" ? true
 str2=="abc" ? false
str1.equals("abc") ? true
str2.equals("abc") ? true
Str2.equals("ABC") ? false
str2.equalsIgnoreCase("ABC") ? true
   
```

str2와 "abc"의 내용이 같은데도 '=='로 비교하면, false를 결과로 얻는다. 내용은 같지만 서로 다른 객체라서 그렇다.
그러나 equals()는 객체가 달라도 내용이 같으면 true를 반환한다.
그래서 문자열을 비교할 때는 항상 equals()를 사용해야 한다는 것을 기억하자.
만일 대소문자를 구별하지 않고 비교하고 싶으면, equals()대신 equalsIgnoreCase()를 사용하면 된다.

### 5.논리 연산자

'x가 4보다 작다'라는 조건은 비교연산자를 써서 ' x < 4 ' 와 같이 표현할 수 있다.
그러면, 'x가 4보다 작거나 또는 10보다 크다'와 같이 두 개의 조건이 결합된 경우는 어떻게 표현해야 할까?
이 떄 사용하는 것이 '논리 연산자'이다. 논리 연산자는 둘 이상의 조건을 '그리고(AND)',나 ''또는(OR)'으로 
연결하여 하나의 식으로 표현할 수 있게 해준다.

5.1 논리 연산자 - &&, ||, !

논리 연산자 '&&'는 우리말로 '그리고(AND)'에 해당하며, 두 피연산자가 모두 true일 때만 true를 결과로 얻는다.
'||'는 '또는(OR)'에 해당하며, 두 피연산자 중 어느 한쪽만 true이어도 true를 결과로 얻는다.
그리고 논리 연산자는 피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만을 허용한다.

```
|| (OR 결합) 피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다.
&& (AND결합) 피연산자 양쪽 모두 true이어야 true를 결과로 얻는다.
```

|참고|  '|'는 한글 키보드에서 Enter키의 바로 위에 있다.

논리 연산자의 피연산자가 '참(true)인 경우와' '거짓(false)인 경우'의 연산결과를 표로 나타내면 다음과 같다.

|   x   |   y   | x \|\| y | x && y |
| :---: | :---: | :------: | :----: |
| true  | true  |   true   |  true  |
| true  | false |   true   | false  |
| false | true  |   true   | false  |
| false | false |  false   | false  |

▲논리 연산자의 연산결과

이제 자주 사용될만한 몇 가지 예를 통해서 논리연산자가 실제로 어떻게 사용되고,
주의해야 할 점은 어떤 것들이 있는지 살펴보자.

#### 1 . x는 10보다 크고 , 20보다 작다

'x > 10' 와 'x < 20' 가 '그리고(and)'로 연결된 조건이므로 다음과 같이 쓸 수 있다.

```java
x > 10 && x < 20
```

' x > 10 '는 ' 10 < x '와 같으므로 다음과 같이 쓸 수도 있다. 보통은 변수를 왼쪽에 쓰지만
이런 경우 가독성측면에서 보면 아래의 식이 더 나을 수 있다.

```java
10 < x && x < 20
```

그렇다고 해서 위의 식에서 논리연산자를 생략하고 '10 < x < 20'과 같이 표현하는 것은 허용되지 않는다.

2. #### i는 2의 배수 또는 3의 배수이다.

어떤 수가 2의 배수라는 얘기는 2로 나누었을 때 나머지가 0이라는 뜻이다. 
그래서 나머지 연산의 결과가 0인지 확인하면 된다. 
'또는'으로 두 조건이 연결되었으므로 논리 연산자 '||'(OR)를 사용해야 한다.

```java
i%2 == 0 || i%3 == 0
```

i의 값이 8일 때, 위의 식은 다음과 같은 과정으로 연산된다.

```java
  i%2 == 0 || i%3 == 0
→ 8%2 == 0 || 8%3 == 0
→  0 == 0  || 2 == 0
→     true || false
→         true
```

#### 3.i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.

이전 조건에 6의 배수를 제외하는 조건이 더 붙었다.
6의 배수가 아니어야 한다는 조건은 'i%6!=0' 이고, 이 조건을 '&&(AND)'로 연결해야 한다.

```java
(i%2 == 0 || i%3 == 0) &&i%6! = 0
```

위의 식에 괄호를 사용한 이유는 '&&'가 '||'보다 우선순위가 높기 때문이다. 
만일 괄호를 사용하지 않으면 '&&'를 먼저 연산한다. 다음의 두 식은 동일하다.

```java
i%2 == 0 || i%3==0  &&  i%6!=0
i%2 == 0 || (i%3==0 && 1%6!=0)    
```

이처럼 하나의 식에 '&&'와 '||'가 같이 포함된 경우, '&&'가 먼저 연산 되어야하는 경우라도 괄호를 사용해서
우선순위를 명확히 해주는 것이 좋다.

#### 4.문자 ch는 숫자('0'~'9')이다.

사용자로부터 입력된 문자가 숫자('0'~'9')인지 확인하는 식은 다음과 같이 쓸 수 있다.

```java
'0' <= ch && ch <= '9'
```

유니코드에서 문자 '0'부터 '9'까지 연속적으로 배치되어 있기 때문에 가능한 식이다.
문자 '0'부터 '9'까지 유니코드는 10진수로 다음과 같다.

```java
   문자 '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' 
문자코드 48    49    50    51    52    53    54    55    56    57
```

그래서 ch의 값이 '5'인 경우 위의 식은 다음과 같은 과정으로 연산된다.

``` java
   '0' <= ch  &&  ch  <=  '9'
 → '0' <= '5' &&  '5' <=  '9'
 →  48 <= 53  &&  53  <=  '57'
 →    true           true
 →            true      
```

#### 5.문자 ch는 대문자 또는 소문자이다.

4의 경우와 마찬가지로 문자'a'부터 'z'까지, 그리고 'A'부터 'Z'까지도 연속적으로 배치되어 있으므로
문자 ch가 대문자 또는 소문자인지 확인하는 식은 다음과 같이 쓸 수 있다.

```java
('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')
```

이제 예제를 통해서 직접 확인해보자.

```java
class test {
    public static void main(String[] args) {
        int x = 0;
        char ch = ' ';
        
        x= 15;
 System.out.printf("x=%2d, 10 < x && x < 20 = %b\n", x , 10 < x && x < 20);
        
        x= 6;
 System.out.printf("x=%2d, x%%2==0 || x%%3==0 && x%%6!=0 =%b\n",x, x%2==0 || x%3 ==0 && x%%6!
                   =0);
 System.out.printf("x=%2d, x%%2==0 || x%%3==0 && x%%6!=0 =%b\n",x, (x%2==0 || x%3 ==0) && x%%6!
                   =0);
        ch ='1';
        System.out.printf("ch='%c', '0' <= ch && ch <= '9' =%b\n", ch, '0' <= ch && ch <= '9');
        ch ='a';
        System.out.printf("ch='%c', 'a' <= ch && ch <= 'z' =%b\n", ch, 'a' <= ch && ch <= 'z');
        ch ='A';
        System.out.printf("ch='%c', 'A' <= ch && ch <= 'Z' =%b\n", ch, 'A' <= ch && ch <= 'Z');
        ch ='q';
        System.out.printf("ch='%c', ch == 'q' || ch == 'Q' =%b\n", ch, 'q' <= ch || ch <= 'Q');
    }
}
```

실행결과

```java
x = 15, 10 < x && x < 20 = true
x = 6,  x%2 == 0 || x%3 == 0  && x%6!=0 = true
x = 6, (x%2 == 0 || x%3 == 0) && x%6!=0 = false
ch = '1', '0' <= ch && ch <= '9' = true
ch = 'a', 'a' <= ch && ch <= 'z' = true
ch = 'A', 'A' <= ch && ch <= 'Z' = true
ch = 'q', 'q' == ch || ch == 'Q' = true
```

지금까지 논리 연산자에 대해 배운 내용들을 확인할 수 있는 간단한 예제이다. 
변수의 값과 조건식을 다양하게 변경해가며 실행하며 결과가 예측과 일치하는지 확인해 보자.

```java
import java.util.*;  //Scanner클래스를 사용하기 위해 추가

class Test {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        char ch = ' ';
        
        System.outp.printf("문자를 하나 입력하세요.>");
        
        String input = scanner.nextLine();
        ch = input.charAt(0);
        
        if ('0' <= ch && ch <= '9') {
            System.out.printf("입력하신 문자는 숫자입니다. \n");
            }
        if(('a'<= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')) {
            System.out.printf("입력하신 문자는 영문자입니다. \n");
        }
    }
}
```

| 실행결과1                                                  | 실행결과 2                                                   |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| 문자를 하나 입력하세요.>7<br />입력하신 문자는 숫자입니다. | 문자를 하나 입력하세요.>a<br />입력하신 문자는 영문자입니다. |

이 예제는 사용자로부터 하나의 문자를 입력받아서 숫자인지 영문자인지 확인한다. 
조건문 if는 괄호()안의 연산결과가 참인 경우 블럭{}내의 문장을 수행한다.
그래서 아래의 코드는 '0'<= ch && ch <= '9'가 참일 때,  화면에 '입력하신 문자는 숫자입니다.' 
라고 출력한다.

```java
if ('0'<= ch && ch <= '9') {
    printf("입력하신 문자는 숫자입니다. \n");
}
```

조건문 if에 대해서는 다음 장에서 자세히 배울 것이므로 가볍게 보고 넘어가자.

#### 효율적인 연산(short circuit evaluation)

논리 연산자의 또 다른 특징은 효율적인 연산을 한다는 것이다. OR연산 '||"의 경우, 
두 피연산자 중 어느 한 쪽만 '참' 이어도 전체 연산결과가 '참'이므로 좌측 피연산자가 'true(참)'이면,
우측 피연산자의 값은 평가하지 않는다.

|   x   |   y   | x  \|\| y |
| :---: | :---: | :-------: |
| true  | true  |   true    |
| true  | false |   true    |
| false | true  |   true    |
| false | false |   false   |

#### 

```
'x가 true이면, x ||y는 항상 true이다.'
```

#### AND연산 '&&'의 경우도 마찬가지로 어느 한쪽만 '거짓(0)'이어도 전체 연산결과가 '거짓(0)'이므로 
좌측 피연산자가 '거짓(0)'이면, 우측 피연산자의 값은 평가하지 않는다.

|   x   |   y   | x&&y  |
| :---: | :---: | :---: |
| true  | true  | true  |
| true  | false | false |
| false | true  | false |
| false | false | false |

#### 

```
'x 가 alse이면, x && y 는 항상 false이다.'
```



그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있는 것이다.
OR연산 '||'의 경우에는 연산결과가 '참'일 확률이 높은 피연산자를 연산자의 왼쪽에 놓아야 더 빠른 연산결과를 얻음

```java
('a'<= ch && ch <= 'Z') || ('A'<= ch && ch <= 'Z')
```

위의 식은 문자 ch가 소문자 또는 대문자인지 확인하는 것인데, 
이 식에서 문자ch가 소문자인 조건을 대문자인 조건보다 왼쪽에 놓았다. 그 이유는 사용자로부터
문자 ch를 입력 받을 때, 사용자가 대문자보다 소문자를 입력할 확률이 높다고 판단했기 때문이다.
실제로 사용자가 소문자를 더 자주 입력한다면, 이 식은 더 효율적으로 처리될 것이다.

```java
class Test {
    public static void main(String[] args) {
        int a = 5;
        int b = 0;
        
        System.out.printf("a=%d , b=%d\n", a, b);
        System.out.printf("a!=0 || ++b!=0 = %b\n", a!=0 || ++b!=0);
        System.out.printf("a=%d, b=%d\n", a, b);
        System.out.printf("a==0 && ++b!=0 = %b\n", a==0 && ++b!=0);
        System.out.printf("a=%d, b=%d\n", a, b);
    }
}
```

실행결과

```java
a = 0 , b = 0
a!=0 || ++b!=0  =  true
a = 5 , b = 0
a==0 && ++b!=0  = false
a = 5 , b = 0
    
```

논리 연산자가 효율적인 연산을 하는지 확인하는 예제이다.
변수 b에 증감연산자 '++'을 사용해서 우측 피연산자가 처리되면, b의 값이 증가하도록 했다.
그러나 실행결과에서 알 수 있듯이, 두 번의 논리연산 후에도 b의 값은 여전히 0인 채로 남아있다.
'|| (OR)'의 경우는 좌측 피연산자(a!=0)가 참이라서, 그리고 '&&(AND)'의 경우는 좌측 피연산자(a==0)가 거짓이라서
우측 피연산자를 펴가하지 않았기 때문이다.

### 논리 부정 연산자 !

이 연산자는 피연산자가 true이면 false를, false면 true를 결과로 반환한다. 
간단히 말해서, true와 false를 반대로 바꾸는 것이다.

|   x   |  !x   |
| :---: | :---: |
| true  | false |
| false | true  |

▲논리 부정 연산자의 연산결과

어떤 값에 논리 부정 연산자 '!'를 반복적으로 적용하면, 참과 거짓이 차례대로 반복된다.
이 연산자의 이러한 성질을 이용하면, 한번 누르면 켜지고, 다시 한 번 누르면 꺼지는 TV의 전원버튼과
같은 '토글 버튼(toggle button)'을 논리적으로 구현할 수 있다.

```java
false(거짓,off) →  true(참,on)  → false(거짓,off)  →  true(참,on)  →   ... 
               !                !                 !               !
```

논리 부정 연산자'!'가 주로 사용되는 곳은 조건문과 반복문의 조건식이며, 이 연산자를 잘 사용하면
조건식이 보다 이해하기 쉬워진다. 
예를 들어 '문자 ch는 소문자가 아니다'라는 조건을 아래의 왼쪽과 같이 쓰기보다 오른쪽과 같이 논리부정연산자'!'를
사용하는 쪽이 알기 쉽다.

```java
ch < 'a' || ch > 'Z'     <->      !('a' <= ch && ch <= 'Z')   
```

위와 같이 논리부정연산자 '!'를 적절히 사용해서 보다 이해하기 쉬운 식이 되도록 노력하자.

```java
class Test {
    public static main String(String[] args) {
        boolean b = true;
        char ch = "C";
        
        System.out.printf("b = %b\n", b);
        System.out.printf("!b=%b\n", !b);
        System.out.printf("!!b = %b\n", !!b);
        System.out.printf("!!!b = %b\n", !!!b);
        System.out.println();
        
      System.out.printf("ch = %c\n", ch);
      System.out.printf("ch < 'a' || ch > 'Z' = %b\n", ch < 'a' || ch > 'z');
      System.out.printf("!('a' <= ch && ch <='z') = %b\n", !( 'a' <= ch && ch <='z'));
      System.out.printf("  'a'<= ch && ch <= 'z' = %b\n", 'a' <= ch && ch <= 'z');
    }
}
```

```java
b = true
!b=false
!!b=true
!!!b=false

ch = c
ch < 'a' || ch > 'z' = true
!('a' <= ch && ch <= 'z') = true
'a' <= ch && ch <= 'z' = false
```

식 '!!b'가 평가되는 과정은 아래와 같다.
단항 연산자는 결합방향이 오른쪽에서 왼쪽이므로 피연산자와 가까운 것부터 먼저 연산된다.
그래서 피연산자인 b와 가까운 논리 부정 연산자'!'가 먼저 수행되어 false를 결과로 얻는다.
그리고 이 값에 다시 '!' 연산을 수행하므로 true를 결과로 얻는다.

```java
  !!b
→ !!true //가까운 연산자가 먼저 연산된다.
→ !false //!true의 결과는 false이다.
→ true   //!false의 결과는 true이다.
```

### 5.2 비트 연산자 & | ^ ~ << >>

비트 연산자는 피연산자를 비트단위로 논리 연산한다.
피연산자를 이진수로 표현했을 때의 각 자리를 아래의 규칙에 따라 연산을 수행하며,
피연산자로 실수는 허용하지 않는다. 정수(문자 포함)만 허용된다.

```java
|(OR연산자) //피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.
&(AND연산자)//피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
^(XOR연산자)//피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.
```

|  x   |  y   | x \| y | x & y | x ^ y |
| :--: | :--: | :----: | :---: | :---: |
|  1   |  1   |   1    |   1   |   0   |
|  1   |  0   |   1    |   0   |   1   |
|  0   |  1   |   1    |   0   |   1   |
|  0   |  0   |   0    |   0   |   0   |

|참고| 연산자 '^'는 배타적 XOR(eXclusive OR)라고 하며, 피연산자의 값이 서로 다른 경우,
          즉 배타적인 경우에만 참(1)을 결과로 얻는다.

비트 OR연산자 '|'는 주로 특정 비트의 값을 변경할 때 사용한다. 
아래의 식은 피연산자 0xAB의 마지막 4bit를 'F'로 변경하는 방법을 보여준다.

121p 참고

비트 AND연산자 '&'는 주로 특정 비트의 값을 뽑아낼 때 사용한다.
아래의 식에서는 피연산자의 마지막 4비트가 어떤 값인지 알아내는데 사용되었다.

비트XOR연산자 '^' 는 두 피연산자의 비트가 다를 때만 1이 된다. 
그리고 같은 값으로 두고 XOR 연산을 수행하면 원래의 값으로 돌아오는 특징이 있어서 간단한 암호화에 사용된다.

122p 참고

지금까지 이해를 돕기 위해 2진수를 8자리로 표현하였지만, 
사실은 int( 4byte)간의 연산이라 32자리로 표현하는 것이 맞다.
그리고 비트연산에서도 피연산자의 타입을 일치시키는'산술 변환'이 일어날 수 있다.

```java
class Test {
    public static void main(String[] args) {
        int x = 0xAB, Y = 0xF;
        
        System.out.printf("x = %#x \t\t%s\n", x, toBinaryString(x));
        System.out.printf("y = %#x \t\t%s\n", y, toBinaryString(y));
        System.out.printf("%#X | %#X = %#X \t%s\n",x, y, x | y, toBinaryString(x | y));
        System.out.printf("%#X & %#X = %#X \t%s\n",x, y, x & y, toBinaryString(x & y));
        System.out.printf("%#X ^ %#X = %#X \t%s\n",x, y, x ^ y, toBinaryString(x ^ y));
        System.out.printf("%#X ^ %#X ^ %#X = %#X %s\n",x, y, y, x ^ y ^ y, toBinaryString(x ^ y ^ y));
    }
    static String toBinaryString(int x) { //10진 정수를 2진수로 변환하는 메서드
        String zero = "00000000000000000000000000";
        String tmp = zero + Integer.toBinaryString(x);
        return tmp.substring(tmp.length()-32);
    }
}
```

실행결과

```java

    x = 0XAB          00000000000000000000000010101011
    y = 0XF           00000000000000000000000000001111
    0XAB | 0XF        00000000000000000000000010101111
    0XAB & 0XF        00000000000000000000000000001011
    0XAB ^ 0XF        00000000000000000000000010100100
    0XAB ^ 0XF ^ 0XF  00000000000000000000000010101011
```

비트연산의 결과를 2진수로 출력하기 위해 toBinaryString()이라는 메서드를 작성해서 사용하였다.
이 메서드는 4 byte의 정수를 32자리의 2진수로 변환한다.
이 메서드가 어떻게 동작하는 지를 이해하기에는 아직 배워야할 것들이 많으므로 설명은 생략한다.

### 비트 전환 연산자 ~

이 연산자는 피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꾼다. 
논리부정 연산자'!'와 유사하다.

|  x   |  ~x  |
| :--: | :--: |
|  1   |  0   |
|  0   |  1   |

▲비트전환 연산자의 2진 연산결과

비트 전환 연산자 '~'에 의해 '비트 전환'되고 나면, 부호있는 타입의 피연산자는 부호가 반대로 변경된다.
즉, 피연산자의 '1의 보수'를 얻을 수 있는 것이다. 그래서 비트전환연산자를 '1의 보수'연산자라고도 한다.

| 2진수                                                        | 10진수             |
| :----------------------------------------------------------- | :----------------- |
| 0 0 0 0 1 0 1 0<br />↓ ↓  ↓ ↓ ↓ ↓ ↓  ↓<br />1 1 1 1 0 1 0  1 | 10<br />↓<br />-11 |



예를 들어 10진수 10을 비트전환 연산한 결과는 -11이고, 이 값은 10의 '1의 보수'이다.
이미 배운 것과 같이 1의 보수에 1을 더하면 음수가 되므로 -11에 1을 더하면 -10이 되고 
-11은 10의 '1의 보수'가 맞다는 것을 확인할 수 있다.

| 2진수                                | 10진수        |
| ------------------------------------ | ------------- |
| 0 0 0 0 1 0 1 0                      | 10            |
| 1 1 1 1 0 1 0 1                      | -11           |
| 1 1 1 1 0 1 0 1<br />0 0 0 0 0 0 0 1 | -11<br />+) 1 |
| 1 1 1 1 0 1 1 0                      | -10           |

위의 표에서는 연산결과를 8자리의 2진수로 표현했지만, 
비트 전환 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환(산술 변환) 후에 연산하기 때문에
연산결과는 32자리의 2진수이다.

```
0 0 0 0 1 0 1 0
```

​        ↓  int타입 (32bit)으로 자동형변환

```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0
```

​        ↓ 1은 0으로, 0은 1로 바뀐다.

```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 
```

```java
class Test {
    public static void main(Stirng[] args) {
        byte p = 10;
        byte n = -10;
        
        System.out.printf(" p = %d \t%s\n", p, toBinaryString(p));
        System.out.printf("~p = %d \t%s\n", ~p, toBinaryString(~p));
        System.out.printf("~p+1 = %d \t%s\n", ~p+1, toBinaryString(~p+1));
        System.out.printf("~~p =%d \t%s\n", ~~p,  toBinaryString(~~p));
        System.out.prinln();
        System.out.printf(" n  =%d\n",  n);
        System.out.printf(" ~ (n-1)=%d\n", ~ (n-1));
    }  
    
    // 10진 정수를 2진수로 변환하는 메서드
    static String toBinaryString(int x) {
        String zero = "00000000000000000000000000000000";
        String tmp = zero + Integer.toBinaryString(x);
        return tmp.substring(tmp.length() - 32);
    }
  }
```

실행결과

```java
 p   = 10   00000000000000000000000000000000
~p   =-11   11111111111111111111111111110101
~p+1 =-10   11111111111111111111111111110110
~~p  =10    00000000000000000000000000001010 
   
n = -10
~ (n - 1) = 10
```

결과를 보면, 어떤 양의 정수에 대한 음의 정수를 얻으려면 어떻게 해야 하는지 알 수 있다.
양의 정수 p가 있을 때, p에 대한 음의 정수를 얻으려면 '~p+1'을 계산하면 된다.
이 사실을 통해서 -10을 2진수로 어떻게 표현할 수 있는지 알 수 있을 것이다.
반대로 음의 정수 n이 있을 때, n에 대한 양의 정수를 얻으려면 '~(n-1)'을 게산하면 된다.
물론 부호연산자 '-'을 사용하면 되므로, 이렇게 복잡하게 변환하지 않는다.
참고로만 알아두자.
'~~p'는 변수 p에 비트 전환 연산을 두 번 적용한 것인데, 
1을 0으로 바꿨다가 다시 0을 1로 바꾸므로 원래의 값이 된다.
그러나 연산결과의 타입이 byte가 아니라 int라는 것에 주의하자.

#### 쉬프트 연산자 << >> 

이 연산자는 피연산자의 각 자리(2진수로 표현했을 때)를 '오른쪽 (>>)' 또는 '왼쪽(<<)'으로 이동(shift)한다고 해서
'쉬프트 연산자(shift operator)'라고 이름 붙여졌다.
예를 들어 ' 8 << 2 '는 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다.
이 때, 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워진다.
이 과정을 그림과 함께 단계별로 살펴보면 다음과 같다.

1. 10진수 8은 2진수로 '00001000'이다.

```java
0 0 0 0 1 0 0 0  // 10진수로 8
```

2. ' 8 << 2 '은 10진수 8의 2진수를 왼쪽으로 2자리 이동시킨다.

   ​        8 << 2

```java
0 0 | 0 0 1 0 0 0 x x     //x는 빈자리 표기
```

3. 자리이동으로 인해 저장범위를 벗어난 값은 버려지고, 빈자리는 0으로 채워진다.

```java
0 0 | 0 0 1 0 0 0 0 0  //빈자리를 0으로 채운다.
```

4. ' 8 << 2 '의 결과는 2진수로 '00100000'이 된다. (10진수로 32)

```java
0 0 1 0 0 0 0 0  // 10진수로 32
```

'<<' 연산자의 경우, 피연산자의 부호에 상관없이 각 자리를 왼쪽으로 이동시키며 빈칸을 0으로만 채우면 되지만,
'>>'연산자는 오른쪽으로 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 왼쪽 피연산자가 음수인 경우
빈자리를 1로 채운다. 물론 양수일 떄는 0으로 채운다.

    ```java
        -8 >> 2 → -2
        1 1 1 1 1 0 0 0
        x x 1 1 1 1 1 0 | 0 0
        1 1 1 1 1 1 1 0 | 0 0
        1 1 1 1 1 1 1 0
    ```

    ```java
       -8 >> 2 → 2
        0 0 0 0 1 0 0 0
        x x 0 0 0 0 1 0 | 0 0
        0 0 0 0 0 0 1 0 | 0 0
        0 0 0 0 0 0 1 0
    ```

쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되어 int보다 작은 타입은 int타입으로 자동 변환되고
연산결과 역시 int타입이 된다. 그러나 쉬프트 연산자는 다른 이항 연산자들과 달리 피연산자의 타입을
일치시킬 필요가 없기 때문에 우측 피연산자에는 산술변환이 적용되지 않는다.



126p십작



---

Chapter 07 객체지향 프로그래밍 II

1. 상속(inheritance)

   1.1 상속의 정의와 장점

   상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.

   상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다.

    이러한 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다. 

   자바에서 상속을 구현하는 방법은 아주 간단하다.

    새로 작성하고자 하는 클래스의 이름뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함게 써주기만 하면 된다. 

   예를 들어 새로 작성하려는 클래스의 이름이Child이고 상속받고자 하는 기존 클래스의 이름이 Parent라면 다음과 같이 하면 된다.

   ```
   class Child extends Parent {
     // ...
   }
   ```

이 두 클래스는 서로 상속 관게에 있다고 하며, 상속해주는 클래스를 '조상클래스'라 하고 상속 받는 클래스를 '자손 클래스'라 한다.

|참고| 서로 상속관계에 있는 두 클래스를 아래와 같은 용어를 사용해서 표현하기도 한다.

- 조상 클래스 - 부모(parent)클래스, 상위(super)클래스,기반(base)클래스
- 자손 클래스 - 자식(child)클래스, 하위(sub)클래스, 파생된(derived) 클래스

자손 클래스는 조상 클래스의 모든 멤버를 상속받기 때문에 , Child클래스는 Parent클래스의 멤버들을 포함한다고 할 수 있다. 

만일 Parent클래스에 age라는 정수형 변수를 멤버변수로 추가하면, 자손 클래스는 조상의 멤버를 모두 상속받기 때문에, Child클래스는 자동적으로 age라는 멤버변수가 추가된것과 같은 효과를 얻는다.



| 클래스 | 클래스의 멤버 |
| :----: | :-----------: |
| Parent |      age      |
| Child  |      age      |

이번엔 반대로 자손인 Child클래스에 새로운 멤버로 play()메서드를 추가해보자.

```java
class Parent {
  int age;
}

```

```java
class Child extends Parent {
void play() { 
System.out.println("놀자");
   }
}
```

| 클래스 | 클래스의 멤버 |
| :----: | :-----------: |
| Parent |      age      |
| Child  |  age, play()  |

Child 클래스에 새로운 코드가 추가되어도 조상인 Parent클래스는 아무런 영향도 받지 않는다. 여기서 알 수 있는것 처럼, 조상 클래스가 변경되면 자손 클래스는 자동적으로 영향을 받게 되지만, 자손 클래스가 변경되는 것은 조상 클래스에 아무런 영향을 주지 못한다.

자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다. 즉, 상속에 상속을 거듭할수록 상속받는 클래스의 멤버 개수는 점점 늘어나겓 ㅚㄴ다.

그래서 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수도 있으며 이것이 상속에 사용되는 키워드가 'extends' 인 이유이기도 하다.

- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.

- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

  |참고|  접근제어자 (access modifier)가 private 또는 default인 멤버들은 상속되지 않는다기보다 상속은 받지만 자손클래스로부터의 접근이 제한되는 것이다.

이번엔 Parent클래스로부터 상속받는 Child2클래스를 새로 작성해보자. Child2클래스를 포함한 세 클래스간의 상속계층도는 다음과 같을 것이다.

```java
class Parent {}
class Child extends Parent{}
class Child2 extends Parent{}
```

클래스 Child와 Child2가 모두 Parent클래스를 상속받고 있으므로 Parent클래스와 Child클래스 ,                                그리고 Parent클래스와 Child2클래스는 서로 상속관계에 있지만 클래스 Child와 Child2간에는                                   서로 아무런 관계도 성립되지 않는다. 클래스 간의 관계에서 형제관계와 같은 것은 없다.                                            부모와 자식의 관계(상속관계)만이 존재할 뿐이다.

만일 Child클래스와 Child2클래스에 공통적으로 추가되어야 하는 멤버(멤버변수나 메서드)가 있다면, 이 두 클래스에 각각 따로 추가해주는 것보다는 이들의 공통조상인 Parent클래스에 추가하는 것이 좋다. Parent클래스의 자손인 Child클래스와 Child2클래스는 조상의 멤버를 상속받기 때문에, Parent클래스에 새로운 멤버를 추가해주는 것은 Child와 Child2클래스에 새로운 멤버를 추가해주는 것고 ㅏ같은 효과를 얻는다. 이제는 Parent클래스 하나만 변경하면 되므로 작업이 간단해진다. 이보다 더 중요한 사실은 같은 내용의 코드를 한 곳에서 관리함으로써 코드의 중복이 줄어든 다는 것이다. 코드의 중복이 많아지면 유지보수가 어려워지고 일관성을 유지하기 어렵다.

이처럼 같은 내용의 코드를 하나 이상의 클래스에 중복적으로 추가해야하는 경우에는 상속관계를 이용해서 코드의 중복을 최소화해야한다. 프로그램이 어떤 때는 잘 동작하지만 어떤 때는 오동작을 하는 이유는 중복된 코드 중에서 바르게 변경되지 않은 곳이 있기 때문이다.

여기에 또다시 Child클래스로부터 상속받는 GrandChild라는 새로운 클래스를 추가한다면 상속계층도는 다음과 같을 것이다.

```java
class Parent {}
class Child extends Parent {}
class Child2 extends Parent {}
class GrandChild extends Child {}
```

자손 클래스는 조상 클래스의 모든 멤버를 물려받으므로 GrandChild클래스는 Child클래스의 모든 멤버, Child클래스의 조상인 Parent클래스로부터 상속받은 멤버까지 상속받게 된다. 그래서 GrndChild클래스는 Child클래스의 자손이면서 Parent클래스의 자손이기도 하다. 좀 더 정확히 말하자면 Child클래스는 GrandChild클래스의 직접 조상이고 , Parent클래스는 GrandChild클래스의 간접 조상이 된다. 그래서 GrandChild클래스는 Parent클래스 와 간접적인 상속관계에 있다고 할 수 있다.

이제 Parent클래스에 전과 같이 정수형 변수인 age를 멤버변수로 추가해 보자.

```java
class Parent {
    int age;
}
class Child extends Parent{}
class Child2 extends Parent{}
class GrandChild extends Child{}
```

|   클래스   | 클래스의 멤버 |
| :--------: | :-----------: |
|   Parent   |      age      |
|   Child    |      age      |
|   Child2   |      age      |
| GrandChild |      age      |



Parent클래스는 클래스 Child, Child2, GrandChild의 조상이므로 Parent클래스에 추가된 멤버변수 age는 Parent클래스의 모든 자손에 추가된다. 반대로 Parent클래스에서 멤버변수 age를 제거 한다면, Parent의 자손클래스인 Child, Child2, grandChild에서도 제거된다. 이처럼 조상 클래스만 변경해도 모든 자손 클래스에, 자손의 자손 클래스에까지 영향을 미치기 때문에, 클래스간의 상속관계를 맺어 주면 자손 클래스들의 공통적인 부분은 조상클래스에서 관리하고 자손 클래스는 자신에 정의된 멤버들만 관리하면 되므로 각 클래스의 코드가 적어져서 관리가 쉬워진다.

전체 프로그램을 구성하는 클래스들을 면밀히 설계 분석하여, 클래스간의 상속관계를 적절히 맺어 주는 것이 객체지향 프로그래밍에서 가장 중요한 부분이다.





​																							