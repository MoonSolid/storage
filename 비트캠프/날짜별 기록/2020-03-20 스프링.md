

#### 컬렉션 타입의 프로퍼티 값 설정 - 배열

ex05

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex05/a/application-context.xml");

    System.out.println(iocContainer.getBean("c1"));
    System.out.println(iocContainer.getBean("c2"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
Car [model=null, maker=null, cc=0, engine=null, tires=[Tire [maker=금호타이어,width=180, ratio=0, wheel=0], Tire [maker=금호타이어, width=180, ratio=0, wheel=0], 
                                                       
Tire [maker=한국타이어, width=180, ratio=0, wheel=0], Tire [maker=한국타이어, width=180, ratio=0, wheel=0], Tire [maker=비트타이어, width=100, ratio=0, wheel=0]]]

    <bean id="c1" class="com.eomcs.spring.ioc.ex05.Car">
    // 배열 프로퍼티 값 설정하기
        <property name="tires">
            <array> //배열 프로퍼티 값을 설정할떄는 <array> 태그를 사용한다
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="금호타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="금호타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="한국타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="한국타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="비트타이어" p:width="100"/>
            </array>
        </property>
    </bean>   
    
    
Car [model=null, maker=null, cc=0, engine=null, tires=[Tire [maker=금호타이어, width=180, ratio=0, wheel=0], Tire [maker=금호타이어, width=180, ratio=0, wheel=0],
                                                       
Tire [maker=한국타이어, width=180, ratio=0, wheel=0], Tire [maker=한국타이어, width=180, ratio=0, wheel=0], Tire [maker=비트타이어, width=100, ratio=0, wheel=0]]]

<bean id="c2" class="com.eomcs.spring.ioc.ex05.Car">
        <!-- 배열 프로퍼티 값 설정하기 -->
        <property name="tires">
            <list>    // <array> 태그 대신 <list> 태그를 사용해도 결과는 같다
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="금호타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="금호타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="한국타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="한국타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.Tire" 
                      p:maker="비트타이어" p:width="100"/>
            </list>
        </property>
    </bean>   

```

---

### 팩토리 메서드 호출 - static 메서드 호출

ex06

```java
public class Exam01 {
  public static void main(String[] args) {
    Car c = CarFactory.create("티코");
    ApplicationContext iocContainer =
        new ClassPathXmlApplicationContext("com/eomcs/spring/ioc/ex06/application-context-01.xml");
    System.out.println(iocContainer.getBean("c1"));
    System.out.println(iocContainer.getBean("c2"));
    System.out.println(iocContainer.getBean("c3"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
Car [model=Tico, maker=대우자동차, cc=890]
<bean id="c1" class="com.eomcs.spring.ioc.ex06.CarFactory"
            //class="스태틱 메서드가 들어있는 클래스 이름"
          factory-method="create">
        //factory-method="스태틱 메서드 이름"    
        <constructor-arg value="티코"/>
    </bean>
 //위 코드를 자바 코드로 변경하면
 //Object obj = CarFactory.create("티코");
 //objPool.put("c1",obj); 
 //가 된다.

Car [model=Sonata, maker=현대자동차, cc=1980]
    
Car [model=자바휘웅, maker=비트자동차, cc=5000]
    
```

---

### 팩토리 메서드 호출 - static 메서드 호출 응용

```java
public class Exam02 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(
        "bitcamp/java106/step06/application-context-02.xml");
      
    Date date = (Date) iocContainer.getBean("d1");
      
    System.out.println(date);
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
2018-05-04
//팩토리 메서드를 통해 객체를 만들기 - 응용
// "yyyy-MM-dd" 형식의 문자열을 가지고 java.sql.Date 객체 만들기   
<bean id="d1" class="java.sql.Date"
    //자바가 기본적으로 제공하는 Date 클래스
  factory-method="valueOf">
    //자바가 기본적으로 제공하는 Date 클래스의 valueOf메서드
  <constructor-arg value="2018-05-04"/>
    //값 설정
</bean>
```

---

### 팩토리 메서드 호출 - 인스턴스 메서드 호출

```java
public class Exam03 {
  public static void main(String[] args) {
    ApplicationContext iocContainer =
        new ClassPathXmlApplicationContext(
        "com/eomcs/spring/ioc/ex06/application-context-03.xml");
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
Car [model=null, maker=SM5, cc=1990]
    
//팩토리 메서드를 통해 객체를 만들기 : 인스턴스 메서드 호출
<bean id="carFactory" class="com.eomcs.spring.ioc.ex06.CarFactory2"/>
//carFactory 아이디의 클래스는 CarFactory2이다
//CarFactory클래스의 create메서드에는 maker,cc값을 설정하는 메서드가 있다

<bean id="c1" factory-bean="carFactory"
//factory-bean 속성을 설정하면 factory-method는 스태틱메서드가 아니라 인스턴스 메서드를
//가리키게 된다. c1 아이디에서 위 carFactory아이디를 호출한다
          factory-method="create">
         //호출한 carFactory의 create메서드 호출
        <constructor-arg value="SM5"/>
    //메서드에서 받은 파라미터값이 SM5이기 때문에 maker는 sm5 , cc는 1990으로 설정된다.
    //case "SM5":
    //    c.setMaker("르노삼성자동차");
    //    c.setMaker("SM5");
    //    c.setCc(1990);
    //    return c;
    
    //자바 코드로 표현하면
    //CarFactory2 carFactory = new CarFactory2();
    //Object obj = carFactory.create("SM5");
    //objPool.put("c1",obj);    
    
    </bean>        
```

---

### 팩토리 메서드 호출 - FactoryBean 구현체

```java
public class Exam04 {
  public static void main(String[] args) {
    ApplicationContext iocContainer =
        new ClassPathXmlApplicationContext("com/eomcs/spring/ioc/ex06/application-context-04.xml");
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
CarFactory3() 생성자 호출됨.
CarFactory3.setModel() 호출됨.
CarFactory3.getObjectType() 호출됨.
CarFactory3.getObject() 호출됨.
Car [model=Sonata, maker=현대자동차, cc=1980]

//팩토리 메서드를 통해 객체를 만들기 : 스프링 규칙에 따라 만들기
<bean id="c1" class="com.eomcs.spring.ioc.ex06.CarFactory3">
  <property name="model" value="소나타"/>
//value에 소나타를 넣어줬기때문에 실행결과로 
//Car [model=Sonata, maker=현대자동차, cc=1980]
    
</bean>
//위 코드를 자바 코드로 표현하면
//CarFactory3 carFactory = new CarFactory3();
//carFactory.setModel("소나타");
//Object obj = null;
//FactoryBean의 구현체 여부에 따라 "c1"이라는 이름으로 저장할 객체가 다르다.
//if (carFactory instanceo	f FactoryBean) {        //carFactory에 구현체가 있으면
//   obj = carFactory.getObject();                //해당구현체를 obj에 저장하고
// } else {                                       //해당구현체가 없으면
//   obj = carFactory;                            //기존 carFactory를
//  }
// objPool.put("c1",obj);                         //저장한다.
    
```

---

### 팩토리 메서드 호출 - FactoryBean 구현체

```java
public class Exam05 {
  public static void main(String[] args) {
           new ClassPathXmlApplicationContext(
               "com/eomcs/spring/ioc/ex06/application-context-05.xml");


    // 이 예제는 Exam04 예제와 같다.
    // 다만 Factory 클래스의 이름을 CarFactory3에서 CarFactoryBean으로 바꾼 것이다.
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
CarFactoryBean() 생성자 호출됨.
CarFactoryBean.setModel() 호출됨.
CarFactoryBean.getObjectType() 호출됨.
CarFactoryBean.getObject() 호출됨.
Car [model=Sonata, maker=현대자동차, cc=1980]

<bean id="c1" class="com.eomcs.spring.ioc.ex06.CarFactoryBean">
           //클래스 이름이 FactoryBean으로 끝나면
           //그 클래스가 FactoryBean 구현체임을 쉽게 눈치챌 수 있다.
        <property name="model" value="소나타"/>
    </bean>
 //위 코드를 자바 코드로 표현하면 
 //CarFactoryBean carFactory = new CarFactoryBean();
 //       carFactory.setModel("소나타");            
 //           Object obj = null;
 // FactoryBean의 구현체 여부에 따라 "c1" 이라는 이름으로 저장할 객체가 다르다.
 //if (carFactory instanceof FactoryBean) {
 //obj = carFactory.getObject();
 //} else {
 //obj = carFactory;
 //}
 //objPool.put("c1", obj);
```

---

### 프로퍼티 에디터 - 기본으로 내장된 프로퍼티 에디터

ex07

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex07/a/application-context.xml");

    System.out.println(iocContainer.getBean("c1"));
    // 실행 오류 발생!
    // 이유?
    // java.lang.String 값을 java.sql.Date 객체로 변환할 수 없어서!
    // 즉 스프링 IoC 컨테이너에 String을 Date으로 바꾸는 변환기가 설치되어 있지 않다.
    //
    // 프로퍼티 에디터?
    // => String 값을 다른 타입의 값으로 변환하는 객체
    //
    // 스프링 빌트인 프로퍼티 에디터(변환기)
    // => primitive 타입 변환기는 기본으로 내장하고 있다.
    // => 따라서 String을
    // byte, short, int, long, float, double, boolean, char로 바꿀 수 있다.
    // => 그 외의 타입은 개발자가 프로퍼티 에디터를 만들어 등록해야 한다.
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
<bean id="c1" class="com.eomcs.spring.ioc.ex07.Car">
        <property name="model" value="티코"/> <!-- String ===> String -->
        <property name="maker" value="비트자동차"/> <!-- String ===> String -->
        <property name="cc" value="890"/> <!-- String ===> int -->
        <property name="auto" value="true"/> <!-- String ===> boolean -->
        
    //자바 원시 타입이 아닌 경우 String을 그 타입으로 자동 변환하지 못한다. 예외 발생!    
        <property name="createdDate" value="2018-5-8"/> <!-- String ===> Date -->
    </bean>
```

---

### 프로퍼티 에디터 - String ==> java.sql.Date 변환기 없이 처리하기

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex07/b/application-context.xml");
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
Car()
Car.setModel()
Car.setMaker()
Car.setCc()
Car.setAuto()
Car.setCreatedDate()
Car [model=티코, maker=비트자동차, cc=890, auto=true,
createdDate=2020-03-20, engine=null]

//String을 java.sql.Date 객체로 바꿔주는 변환기가 없기 떄문에 
//직접 Date 객체를 생성해야 한다. 단, 이방식은 날짜 프로퍼티 값을 설정할 때마다
//매번 작성해야 하기 때문에 불편하다.
//해결책
//String을 java.sql.Date 객체로 변환해주는 프로퍼티 에디터를 등록하면 된다.
<bean id="c1" class="com.eomcs.spring.ioc.ex07.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
        <property name="createdDate">           
            //java.sql.Date클래스의 벨류값을 설정해줄 프로퍼티 에디터
            <bean class="java.sql.Date" factory-method="valueOf">
                                 //value="날짜 값"
                <constructor-arg value="2020-3-20"/>
            </bean>
        </property>
    </bean>
```

---

### 프로퍼티 에디터 - String ==> java.sql.Date 변환기를 사용하여 처리하기

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex07/c/application-context.xml");
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
Car()
CustomDateEditor.setValue()
CustomDateEditor.setAsText()
CustomDateEditor.setValue()
CustomDateEditor.getValue()
Car.setModel()
Car.setMaker()
Car.setCc()
Car.setAuto()
Car.setCreatedDate()
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=2020-03-20, engine=null]
    
<bean id="c1" class="com.eomcs.spring.ioc.ex07.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
    
    //String을 java.sql.Date 객체로 바꿔주는 프로퍼티 에디터(변환기)가 
    //설정되었기 때문에 이제 그냥 문자열을 지정해도 된다.  
        <property name="createdDate" value="2020-3-20"/>
              
    </bean>
    //String값을 java.sql.Date 객체로 변환시키는 프로퍼티 에디터 장착하기
    //Spring IoC 컨테이너가 XML 설정 파일을 읽을 때:
    //만약 CustomEditorConfigurer 객체가 정의되어 있다면 
    //그 객체를 설정파일에 정의된 대로 만들고 준비시킨다.
    //그리고 프로퍼티 값을 저장할 때 이 객체에 정의된 프로퍼티 에디터를 사용할 것이다.
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
	    <property name="customEditors"> 
            //setCustomEditor(Map<Class,Class>param) {...}
	        <map>
	//프로퍼티 에디터를 설정하는 방법
    //key: String 값을 어떤 타입의 값으로 바꿀 것인지에 대한 타입 이름이다.
	//value: 커스텀 에디터(프로퍼티 값 변환기) 클래스 이름이다.
    //의미 : 스프링 IoC 컨테이너가 프로퍼티 값을 설정할 때 
    //특히 String 값을 java.sql.Date 객체로 바꿔야 할 때
    //이 클래스를 사용하여 값을 바꾸라는 뜻이다.   
	            <entry key="java.sql.Date" 
                     // key="바꿀타입"
	                   value="com.eomcs.spring.ioc.ex07.c.CustomDateEditor"/>
                     // value=프로퍼티 값 변환에 쓰일 클래스 이름        
	        </map>
	    </property>       
 
```

### 프로퍼티 에디터 만들기

```java
//프로퍼티 에디터 만들기
    
//프로퍼티 에디터 만드는 방법
// => java.beans.PropertyEditor 인터페이스를 구현하면 된다.
// => 그러나 이 인터페이스를 직접 구현하려면 많은 (12r개의 메서드)를 모두 구현해야 한다.
// 하지만 번거롭기 때문에
// 자바는 PropertyEdtor를 미리 구현한 PropertyEditorSupport 라는 클래스를 제공한다.
// 따라서 인터페이스를 직접 구현하지말고 이 클래스를 상속받는다.
// 1) java.beans.PropertyEditorSupports를 상속 받는다.

    public class CustomDateEditor extends PropertyEditorSupport {
  //이 메서드는 스프링 IoC 컨테이너가 String 타입의 프로퍼티 값을
  //다른 타입의 값으로 바꿀 때 호출하는 메서드이다.
  @Override
  public void setAsText(String text) throws IllegalArgumentException {
    System.out.println("CustomDateEditor.setAsText()");
    //파라미터로 넘어온 String 타입의 프로퍼티 값을
    //원하는 타입(Java.sql.Date)의 값으로 바꿔 내부에 저장한다.    
    this.setValue(Date.valueOf(text));
      //파라미터로 넘어온 text를 Date 객체로 변환
  }

  // 언제 어떤 메서드가 호출되는지 확인하기 위해 상속 받은 메서드를 오버라이딩 해보자!
  @Override
  public void setValue(Object value) {
    // 이 메서드는 호출되었을 때 그것을 표시하기 위해 오버라이딩 했다.
    System.out.println("CustomDateEditor.setValue()");
    super.setValue(value); // 원래 하던 일을 수행한다.
  }

  @Override
  public Object getValue() {
    // 이 메서드는 호출되었을 때 그것을 표시하기 위해 오버라이딩 했다.
    System.out.println("CustomDateEditor.getValue()");
    return super.getValue(); // 원래 하던 일을 수행한다.
  }
}
```

---

## 프로퍼티 에디터 - String ==> Engine 프로퍼티 에디터 변환기를 사용하여 처리하기

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex07/d/application-context.xml");

    System.out.println(iocContainer.getBean("c1"));

    System.out.println("----------------------------");

    // SpringUtils.printBeanNames(iocContainer);
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------    
Car()
CustomDateEditor.setValue()
CustomDateEditor.setAsText()
CustomDateEditor.setValue()
CustomDateEditor.getValue()
Car.setModel()
Car.setMaker()
Car.setCc()
Car.setAuto()
Car.setCreatedDate()
Car.setEngine()
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=2018-05-08, engine=Engine [maker=비트자동차, valve=16, cylinder=4]]

    <bean id="c1" class="com.eomcs.spring.ioc.ex07.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
        <property name="createdDate" value="2018-5-8"/>
        <property name="engine" value="비트자동차,16,4"/>
     //자바 코드로 표현
     //스프링 IoC 컨테이너는 String 을 Engine 객체로 변환시켜줄 프로퍼티 에디터를 찾는다.
     //그 에디터를 사용하여 문자열을 Engine 객체로 바꾼다.
     //customEngineEditor.setAdText("비트자동차,16,4");
     //customEngineEditor의 setAdText메서드에 "비트자동차,16,4"를 넘겨준다
        
    public void setAsText(String text) throws IllegalArgumentException {
    String[] values = text.split(",");
    Engine engine = new Engine();
    engine.setMaker(values[0]);
        //비트자동차
    engine.setValve(Integer.parseInt(values[1]));
        //16
    engine.setCylinder(Integer.parseInt(values[2]));
        //4
    this.setValue(engine);
  }        
    </bean>    
    <bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
	    <property name="customEditors">
	        <map>
	            <entry key="java.sql.Date" 
	                   value="com.eomcs.spring.ioc.ex07.c.CustomDateEditor"/>
	            <entry key="com.eomcs.spring.ioc.ex07.Engine" 
                                  //변환할 프로퍼티 타입
                     value="com.eomcs.spring.ioc.ex07.d.CustomEngineEditor"/>
                                  //변환할때 사용할 EngineEditor
	        </map>
	    </property>
	</bean>
```

---

### 의존 객체 주입 자동화하기 - 자동화 전, XML 설정을 통한 수동 주입

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/a/application-context.xml");

    // Car 객체를 꺼내 Engine 객체가 주입되었는지 확인해보자!
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------   
Car [model=티코, maker=비트자동차, cc=890, auto=true,createdDate=null,
     engine=Engine [maker=비트자동차, valve=16, cylinder=4]]
     //c1에 엔진객체를 주입했기 때문에 engine의 maker,value,cylinder 출력
<bean id="c1" class="com.eomcs.spring.ioc.ex08.a.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
     // 의존 객체 주입(Dependency Injection; DI)
        <property name="engine" ref="e1"/>
     //의존 객체 주입
    </bean>
    
    <bean id="e1" class="com.eomcs.spring.ioc.ex08.a.Engine">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>       
     
```

---

### 의존 객체 주입 자동화하기 - 셋터에 @Autowired 애노테이션 붙이기

```java
public class Exam01 {
  public static void main(String[] args) { 
   // 1) 스프링 IoC 컨테이너는 객체를 만든다.
   // 2) 프로퍼티 값을 설정한다.
   // 3) 객체 생성 후 IoC 컨테이너에 등록된 리스너(BeanPostProcessor)에게 통보한다.   
   // 4) AutowiredAnnotationBeanPostProcessor 리스너가 있다면,
   // @Autowired 애노테이션을 처리한다.
      
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/b/application-context.xml");  
    SpringUtils.printBeanList(iocContainer);  
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------   
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=null,
engine=Engine [maker=비트자동차, valve=16, cylinder=4]]
//Car에 따로 의존객체를 주입하지 않아도 
//Car클래스의 setEngine메서드에 @Autowired 애노테이션이 붙어있기 때문에
//@Autowired애노테이션 도우미를 통해 Car에 engine을 주입한다

    //Car의 Engine 셋터에 애노테이션이 붙여있다
    @Autowired
  public void setEngine(Engine engine) {
    System.out.println("Car.setEngine()");
    this.engine = engine;
  }
    
//의존 객체를 자동 주입하는 기능을 사용하고싶다면 그 일을 할 객체를 등록하면된다.
//그 객체는 AutowiredAnnotationBeanPostProcessor 이다
//이 객체를 사용하려면 셋터 메서드 또는 필드에 @Autowired를 붙이면 된다.
//@Autowired 애노테이션을 셋터 메서드에 붙였다고 해서
//의존 객체가 자동 주입되는 것이 아니다.
//@Autowired 애노테이션이 붙은 셋터에 대해 프로퍼티 값을 자동으로 주입하는 일을 
//할 객체를 등록해야 한다.
//@Autowired 애노테이션 도우미 등록방법:
//다음의 객체를 등록하면 된다.  
   //org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
//동작원리: Spring IoC 컨테이너가 설정 파일에 적혀있는 대로 객체를 생성한다.
//객체 생성 후에 BeanPostProcessor에게 보고한다.
//AutowiredAnnotationBeanPostProcessor는 생성된 객체에 대해
//@Autowired 애노테이션을 검사하여 
//이 애노테이션이 붙은 프로퍼티 값을 자동 주입하는 일을 한다.
//이 객체를 스프링 IoC 컨테이너에 등록하지 않으면
//@Autowired 애노테이션은 처리되지 않는다.
    
//객체 생성 후 작업을 수행하는 역할자를 정의하는 방법:
//BeanPostProcessor 규칙에 따라 클래스를 정의한 후 객체를 등록하면 된다.
//BeanPostProcessor 인터페이스:스프링 IoC 컨테이너는 객체 중에
//이 인터페이스를 구현한 객체가 있다면, 설정 파일에 적혀있는 객체를 생성한 후에
//이 구현체의 postProcess....()메서드를 호출한다.
//즉 빈 생성 이후의 마무리 작업을 진행시킨다. 그래서 이 인터페이스의 이름이
//BeanPostProcessor(객체 생성 후 처리기) 인 것이다.
    
<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>    
  //@Autowired 애노테이션 도우미       
    
    <bean id="c1" class="com.eomcs.spring.ioc.ex08.b.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
        //engine 객체를 주입하지 않았다.                 
    </bean>    
    <bean id="e1" class="com.eomcs.spring.ioc.ex08.b.Engine">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>
```

---

### BeanPostProcessor 사용법 - 동작 원리

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/c1/application-context.xml");
    // Spring IoC 컨테이너에 들어 있는 객체 출력
    SpringUtils.printBeanList(iocContainer);
    // Car 객체를 꺼내 Engine 객체가 주입되었는지 확인해보자!
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
postProcessBeforeInitialization()
    => e1 : com.eomcs.spring.ioc.ex08.c1.Engine
    => Engine [maker=비트자동차, valve=16, cylinder=4]
Engine().init()
postProcessAfterInitialization()
    => e1 : com.eomcs.spring.ioc.ex08.c1.Engine
    => Engine [maker=비트자동차, valve=16, cylinder=4]
--------------------------------
빈 개수: 3
com.eomcs.spring.ioc.ex08.c1.MyBeanPostProcessor#0 = com.eomcs.spring.ioc.ex08.c1.MyBeanPostProcessor
c1 = com.eomcs.spring.ioc.ex08.c1.Car
e1 = com.eomcs.spring.ioc.ex08.c1.Engine
--------------------------------
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=null, engine=null]
 
//BeanPostProcessor 인터페이스 구현체 만들고 등록하기
//BeanPostProcessor 인터페이스 : 
// => 스프링 IoC 컨테이너는 객체 중에 이 인터페이스를 구현한 객체가 있다면,
//설정 파일에 적혀있는 객체를 생성한 후에
//이 구현체의 postProcess....() 메서드를 호출한다.
//즉 빈 생성 이후의 마무리 작업을 진행시킨다.
//그래서 이 인터페이스의 이름이 BeanPostProcessor(객체 생성 후 처리기)인 것이다.
    

<bean class="com.eomcs.spring.ioc.ex08.c1.MyBeanPostProcessor"/>    
//밑의 init-method="init" 메서드가 호출되기 전에 위 MyBeanPostProcessor에 있는    
//메서드가 먼저 호출된다    
    <bean id="c1" class="com.eomcs.spring.ioc.ex08.c1.Car" init-method="init">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
    </bean>
    
    <bean id="e1" class="com.eomcs.spring.ioc.ex08.c1.Engine" init-method="init">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>
        
//Spring IoC 컨테이너에 새 기능을 추가하는 예:
//=> 새 기능이 IoC 컨테이너가 생성한 객체를 사용해야 한다면,
//객체 생성 후에 그 작업을 수행하면 된다.
//=> 이렇게 개발자가 컨테이너의 기능을 확장할 수 있도록
//BeanPostProcessor라는 규칙을 제공한다.

//즉 빈 생성 후에 어떤 작업을 수행할 객체를 만들고 싶다면
//=> BeanPostProcessor 규칙에 따라 클래스를 만들어야한다
//=> 옵저버 디자인 패턴이 적용된 대표적인 예이다.
        
//BeanPostProcessor 
//=> 스프링 IoC 컨테이너는 빈을 생성하고 세터를 모두 호출한 후
//이 구현체에게 보고한다.       
 public class MyBeanPostProcessor implements BeanPostProcessor {
  public MyBeanPostProcessor() {
    System.out.println("MyBeanPostProcessor()");
  }     
     
  @Override
  public Object postProcessBeforeInitialization( //
      Object bean, String beanName) throws BeansException {
  // XML 설정에서 init-method 속성에 지정된 메서드가 호출되기 전에
  //이 메서드가 먼저 호출된다.
    System.out.println("postProcessBeforeInitialization()");
    System.out.printf("    => %s : %s\n", //
        beanName, //
        bean.getClass().getName());
    System.out.printf("    => %s\n", bean.toString());
    return bean;
  }

  @Override
  public Object postProcessAfterInitialization(//
      Object bean, String beanName) throws BeansException {
    // XML 설정에서 init-method 속성에 지정된 메서드가 호출된 후에
    // 이 메서드가 호출된다.
    //
    System.out.println("postProcessAfterInitialization()");
    System.out.printf("    => %s : %s\n", //
        beanName, //
        bean.getClass().getName());
    System.out.printf("    => %s\n", bean.toString());
    return bean;
  }
}
```

---

### BeanPostProcessor 사용법 - BeanPostProcessor 활용 예

```java
public class Exam01 {
  public static void main(String[] args) {
 // Spring IoC 컨테이너가 생성한 객체의 클래스 명을 로그로 남기고 싶다면
 // => LogBeanPostProcessor를 만들어 처리한다.     
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/c2/application-context.xml");
    // Spring IoC 컨테이너에 들어 있는 객체 출력
    SpringUtils.printBeanList(iocContainer);
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
LogBeanPostProcessor()
===> java.util.ArrayList
===> java.util.HashSet
===> java.lang.Math
//생성한 객체 클래스명의 로그    
<bean class="java.util.ArrayList"/>
<bean class="java.util.HashSet"/>
<bean class="java.lang.Math"/>    
// BeanPostProcessor 인터페이스 구현체 만들고 등록하기
<bean class="com.eomcs.spring.ioc.ex08.c2.LogBeanPostProcessor"/>    
//LogBeanPostProcessor
//역할 :
// IoC 컨테이너가 빈을 생성할 때 마다 로그를 출력한다.

public class LogBeanPostProcessor implements BeanPostProcessor {
  public LogBeanPostProcessor() {
    System.out.println("LogBeanPostProcessor()");      
  }
  @Override
  public Object postProcessBeforeInitialization(Object bean, String beanName)
      throws BeansException {
    return null;
  }
  @Override
  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    System.out.println("===> " + bean.getClass().getName());
      //빈을 생성할 때마다 로그 출력
    return null;
  }    
}
```

---

### BeanPostProcessor 사용법 - BeanPostProcessor를 이용하여 @Autowired 애노테이션 처리하기

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/c3/application-context.xml");
    // Spring IoC 컨테이너에 들어 있는 객체 출력
    SpringUtils.printBeanList(iocContainer);
    // Car 객체를 꺼내 Engine 객체가 주입되었는지 확인해보자!
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
Car.setAuto()
Car.init()
MyAutowiredAnnotationBeanPostProcessor.postProcessAfterInitialization()
Engine()
Engine.setMaker()
Engine.setValve()
Engine.setCylinder()
Engine().init()
MyAutowiredAnnotationBeanPostProcessor.postProcessAfterInitialization()
Car.setEngine()
--------------------------------
빈 개수: 3
com.eomcs.spring.ioc.ex08.c3.MyAutowiredAnnotationBeanPostProcessor#0 = com.eomcs.spring.ioc.ex08.c3.MyAutowiredAnnotationBeanPostProcessor
c1 = com.eomcs.spring.ioc.ex08.c3.Car
e1 = com.eomcs.spring.ioc.ex08.c3.Engine
--------------------------------
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=null, engine=Engine [maker=비트자동차, valve=16, cylinder=4]]

//@Autowired 애노테이션을 처리할 BeanPostProcessor를 등록한다.
<bean class="com.eomcs.spring.ioc.ex08.c3.MyAutowiredAnnotationBeanPostProcessor"/>
    
    <bean id="c1" class="com.eomcs.spring.ioc.ex08.c3.Car" init-method="init">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
    </bean>
    
    <bean id="e1" class="com.eomcs.spring.ioc.ex08.c3.Engine" init-method="init">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>
        
//MyAutowiredAnnotationBeanPostProcessor
        
//@Autowired 애노테이션을 처리해주는 역할을 한다.
//스프링 IoC 컨테이너가 객체를 생성한 후 보고를 하면
//이 클래스는 생성된 객채에서 @Autowired가 붙은 세터를 찾는다.
//있다면 세터를 호출하여 의존 객체를 주입한다.    
//의존 객체가 없다면 그 의존 객체가 생성될 때까지
//별도로 담아 둔다.
//의존 객체가 생성되는 순간 즉시 별도로 담아 둔 그 객체에 대해 셋터를 호출할 것이다.     
public class MyAutowiredAnnotationBeanPostProcessor implements BeanPostProcessor {    
  //생성된 모든 객체를 기록한다.
  HashMap<Class<?>, List<Object>> beans = new HashMap<>();

  //파라미터 값이 준비되지 않아서 호출이 연기된 @Autowired 메서드를 기록한 맵
  HashMap<Class<?>, List<AutowiredMethod>> autowiredMethods = new HashMap<>();

  private void addBean(Class<?> type, Object bean) {
    List<Object> objList = beans.get(type); //해당 타입의 객체 목록을 꺼낸다.
    if (objList == null) {  //해당 타입의 객체 목록이 없다면,
      objList = new ArrayList<>(); //새로 객체를 저장할 목록을 준비한다.
      beans.put(type, objList);  //해당 타입의 객체를 저장할 목록을 맵에 추가한다.
    }
    objList.add(bean); //해당 타입의 객체 목록에 새 객체를 추가한다.
  }

  private Object getBean(Class<?> type) {
    List<Object> objList = beans.get(type);  //해당 타입의 객체 목록을 꺼낸다.
    if (objList == null) {  //해당 타입의 객체 목록이 없다면,
      return null;
    }
    return objList.get(0); //객체 목록에서 첫 번째 객체를 꺼낸다.
  }

  //객체에 대해 모든 초기화가 끝난 후에 @Autowired 애노테이션을 처리한다
  //따라서 다음 메서드만 오버라이딩 한다.
  @Override
  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    System.out.println("MyAutowiredAnnotationBeanPostProcessor.postProcessAfterInitialization()");

    //새로 생성된 객체를 기록한다.
    addBean(bean.getClass(), bean);

    // 해당 빈에서 @Autowired가 붙은 메서드를 찾아 호출하거나 호출을 연기시킨다.
    callAutowiredMethod(bean);

    //해당 빈을 필요로 하는 셋터 메서드를 찾아 호출한다.
    injectDependency(bean);

    return bean;
  }

  private void addAutowiredMethod(Class<?> paramType, AutowiredMethod autowiredMethod) {

    //해당 의존 객체에 대해 나중에 호출하기 위해 모아둔 메서드 목록을 꺼낸다.
    List<AutowiredMethod> methods = autowiredMethods.get(paramType);

    if (methods == null) { //의존객체를 주입할 메서드 목록이 없다면,
      methods = new ArrayList<>(); //메서드 목록을 새로 준비한다.
      autowiredMethods.put(paramType, methods); //그리고 맵에 등록한다.
    }

    // 목록에 셋터 메서드 정보(셋터메서드 + 객체)를 추가한다.
    methods.add(autowiredMethod);
  }


  // 객체의 @Autowired가 붙은 메서드를 모두 찾아 호출한다.
  private void callAutowiredMethod(Object bean) {
    //이 객체의 모든 public 메서드를 꺼낸다.
    Method[] methods = bean.getClass().getMethods();

    // public 메서드 중에서 @Autowired로 표시된 메서드를 찾는다.
    for (Method m : methods) {

      // 메서드에서 @Autowired 애노테이션이 있는지 확인한다.
      Autowired anno = m.getAnnotation(Autowired.class);

      if (anno == null) {
        continue;
      }

      // @Autowired 가 붙은 메서드를 찾았으면 호출하여 의존 객체를 주입한다.

      // => 먼저 어떤 타입의 의존 객체인지 알아낸다. 메서드의 파라미터 타입을 알아낸다.
      Class<?> paramType = m.getParameters()[0].getType();

      // => 파라미터 타입의 객체를 보관소에서 꺼낸다.
      Object dependency = this.getBean(paramType);

      if (dependency != null) { // 해당 의존 객체가 있다면
        // 셋터를 호출한다.
        try {
          m.invoke(bean, dependency);
        } catch (Exception e) {
          e.printStackTrace();
        }
      } else { // 셋터가 원하는 파라미터 값이 없다면,
        // 일단 그 값이 나타날 때까지 호출을 연기하자!
        // 즉 호출될 메서드 목록에 추가한다.
        addAutowiredMethod(paramType, new AutowiredMethod(bean, m));
      }
    }
  }

  private void injectDependency(Object dependency) {
    // 이 메서드에서 파라미터로 받은 객체를 원하는 셋터가 있는지 확인한다.
    // => 즉 이 타입의 객체를 받기 위해 호출이 연기된 메서드가 있는지 확인한다.
    List<AutowiredMethod> setters = autowiredMethods.get(dependency.getClass());

    if (setters == null) {
      return;
    }

    // 이 객체를 간절히 원하는 셋터 메서드가 있다면 호출하여 주입한다.
    while (setters.size() > 0) {
      AutowiredMethod setter = setters.remove(0);
      try {
        setter.method.invoke(setter.object, dependency);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }


  class AutowiredMethod {
    Object object; // 메서드를 호출할 때 사용할 인스턴스
    Method method; // @Autowired가 붙은 메서드

    public AutowiredMethod(Object object, Method method) {
      this.object = object;
      this.method = method;
    }
  }
}

//결론 : 의존객체를 주입할때 주입받을 객체의 의존객체 세터메서드에 Autowired 애노테이션을 붙인다
```

---

### 의존 객체 주입 자동화하기 - 인스턴스 변수에 @Autowired 애노테이션 붙이기

```java
public class Exam01 {
  public static void main(String[] args) {
    // @Autowired 애노테이션을 필드(인스턴스 변수)에 붙여도 된다.
    // 그러면 의존 객체를 직접 변수에 주입한다.
    // 셋터를 호출하지 않는다. 즉, 셋터가 없어도 된다.
    // 인스턴스 변수에 직접 의존 객체를 주입한다는 것은
    // 캡슐화(즉 외부에서 직접 인스턴스 변수에 접근하는 것을 막는 기법)을
    // 위배하는 측면이 있기 떄문에
    // 이방식은 "객체지향을 파괴하는 방식"이라는 비난을 받는다.
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/e/application-context.xml");

    // Spring IoC 컨테이너에 들어 있는 객체 출력
    SpringUtils.printBeanList(iocContainer);
    // Car 객체를 꺼내 Engine 객체가 주입되었는지 확인해보자!
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
 Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=null, engine=Engine [maker=비트자동차, valve=16, cylinder=4]]   
    
//AutowiredAnnotationBeanPostProcessor은 @Autowired가 셋터 뿐만 아니라
//필드에 붙은 경우도 처리한다.
<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
    <bean id="c1" class="com.eomcs.spring.ioc.ex08.e.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
    </bean>    
---------------------------------------------------------------    
  //필드에 @Autowired를 붙인 경우, 셋터를 통해 값을 넣는 것이 아니라,
  //인스턴스 필드에 직접 값을 넣는다. private 이라도 상관없다.
  //따라서 셋터를 정의하지 않아도 된다.
  @Autowired
  private Engine engine;
---------------------------------------------------------------        
    <bean id="e1" class="com.eomcs.spring.ioc.ex08.e.Engine">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>
        
 //결론 : @Autowired는 변수에도 붙일 수 있으나 사용을 지양한다.       
```

---

### 의존 객체 주입 자동화하기 - 생성자를 이용하여 의존 객체 주입

```java
public class Exam01 {

  public static void main(String[] args) {

 //생성자를 통해 의존 객체를 주입할 수 있다.
 //=> AutowiredAnnotaionBeanPostProcessor가 이것 또한 처리해준다.
 //=> 해당 클래스에 기본 생성자가 없을 때,
 //파라미터를 받는 다른 생성자를 찾아 호출한다.
 //=> 물론 그 파라미터에 해당하는 객체가 존재해야 한다.      
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/f/application-context.xml");

    // Spring IoC 컨테이너에 들어 있는 객체 출력
    SpringUtils.printBeanList(iocContainer);

    // Car 객체를 꺼내 Engine 객체가 주입되었는지 확인해보자!
    System.out.println(iocContainer.getBean("c1"));

  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
    
빈 개수: 3
org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#0 = org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
c1 = com.eomcs.spring.ioc.ex08.f.Car
e1 = com.eomcs.spring.ioc.ex08.f.Engine
--------------------------------
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=null, engine=Engine [maker=비트자동차, valve=16, cylinder=4]]
    
// AutowiredAnnotationBeanPostProcessor는 기본 생성자가 없으면 파라미터를 
// 받는 다른 생성자를 호출하여 객체를 생성한다.
<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
    
    <bean id="c1" class="com.eomcs.spring.ioc.ex08.f.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
    </bean>
----------------------------------------------------------------
    //의존객체를 주입받을 클래스 생성자의 파라미터에 의존객체를 주입한다    
    //@Autowired는 안붙여도 된다. (붙여도 된다)
    //이 일 또한 AutowiredAnnotationBeanPoistProcessor 객체가 처리한다.
    public Car(Engine engine) {        
    System.out.println("Car(Engine)");
    this.engine = engine;
  }
    //셋터를 정의하지 않아도 된다.
----------------------------------------------------------------        
        
    
    <bean id="e1" class="com.eomcs.spring.ioc.ex08.f.Engine">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>
        //결론 : 생성자의 파라미터에서 의존객체를 주입할 수 있다.
```

---

### 의존 객체 주입 자동화하기 - 필수 의존 객체와 선택 의존 객체

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/g/application-context.xml");
    // Spring IoC 컨테이너에 들어 있는 객체 출력
    SpringUtils.printBeanList(iocContainer);
    // Car 객체를 꺼내 Engine 객체가 주입되었는지 확인해보자!
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
Car()
--------------------------------
빈 개수: 2
org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#0 = org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
c1 = com.eomcs.spring.ioc.ex08.g.Car
--------------------------------
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=null, engine=null]

<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
    
    <bean id="c1" class="com.eomcs.spring.ioc.ex08.g.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
    </bean>
------------------------------------------------------------
//Car 클래스
//의존 객체 Engine 주입 - 필수 또는 선택
//@Autowired의 required 값은 기본이 true이다.
//즉 의존객체 주입이 필수사항이다.
//선택사항으로 바꾸고 싶으면         
  @Autowired(required = false)            
  private Engine engine;        
------------------------------------------------------------        
//결론 : @Autowired의 required옵션을 통해 의존객체를 원하는 경우에만 주입할 수 있다.
```

---

### 의존 객체 주입 자동화하기 - 같은 타입의 의존 객체가 여러개 있을 때

```java
public class Exam01 {

  public static void main(String[] args) {
//같은 타입의 의존 객체가 여러 개 있을 때
//그중 어떤 객체를 주입해야 할 지 알 수 없기 떄문에
//Spring IoC 컨테이너는 예외를 발생시킨다.
//해결책
//@Qualifier 애노테이션을 사용하여 주입할 객체를 지정한다.

//주의
// AutowiredAnnotationBeanPostProcessor는 
// @Qualifier애노테이션을 처리하지 못한다.
// 따라서 @Qualifier 애노테이션을 처리할 BeanPostProcessor를
// 따로 등록해야 한다.      
ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
  "com/eomcs/spring/ioc/ex08/h/application-context.xml");

    // Spring IoC 컨테이너에 들어 있는 객체 출력
    SpringUtils.printBeanList(iocContainer);

    // Car 객체를 꺼내 Engine 객체가 주입되었는지 확인해보자!
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=null, engine=Engine [maker=비트자동차, valve=16, cylinder=4]]
//클래스에 붙은 특정 애노테이션을 처리할 BeanPostProcessor 등록하기
//@Autowired => AutowiredAnnotationBeanPostProcessor
//@Qualifier => 
//@Resources => ?
//@...       => ?
//위와 같이 특정 애노테이션을 처리하고 싶다면
//그 애노테이션을 처리할 객체를 등록해야 한다.    
//문제는, 각가의 애노테이션에 대해 어떤 클래스가 처리하는지 암기를 해야하고,
//또한 다음 AutowiredAnnotationBeanPostProcessor의 경우와 같이
//<bean>    태그를 이용하여 그 객체를 등록해야 한다.
//결론 : 매우 번거롭다
//스프링 프레임워크는 애노테이션을 처리할 클래스를
//자동 등록하는 특별한 단축 태그를 제공한다.
<context:annotation-config/>  
//위의 태그를 추가하면, 개발자가 일일이 BeanPostProcessor를 등록할 필요가 없다.
//내부적으로 관련된 BeanPostProcessor를 자동으로 등록한다.
//따라서 개발자는 각각의 애노테이션을 처리할 BeanPostProcessor를 외우지 않아도 된다.   //이 태그를 추가하면 @Qualifier 애노테이션을 처리할 BeanPostProcessor가 자동등록된다.
    
    <bean id="c1" class="com.eomcs.spring.ioc.ex08.h.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
    </bean>
--------------------------------------------------------------------------------
Car 클래스
@Autowired
@Qualifier("e2")  
//"e2"객체 주입
//의존 객체가 여러 개 있을 경우, 주입할 의존 객체의 이름을 지정해야한다.      
//@Qualifier 애노테이션을 처리할 BeanPostProcessor를 등록해야 한다.        
private Engine engine;        
--------------------------------------------------------------------------------        
    <bean id="e1" class="com.eomcs.spring.ioc.ex08.h.Engine">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>
    
    <bean id="e2" class="com.eomcs.spring.ioc.ex08.h.Engine">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>    
        
// 결론 :  <context:annotation-config/>를 사용하면 여러 타입의 의존객체를 주입할때
// 편하다, 주입할때 @Qualifier("주입할 객체명")로 객체명을 지정해줘야한다
// ex) @Autowired,@Qualifier("e2")  
```

---

### 의존 객체 주입 자동화하기 - @Resuouce = @Autowired + @Qualifier

```java
public class Exam01 {
  public static void main(String[] args) {
//@Autowired와 @Qulifier를 묶어서 사용하는 대신에 
//자바 언어 확장 명세서 'JSR-250'      에 정의된 @Resource를 사용할 수 있다.
//단 이 애노테이션을 사용하려면 이 애노테이션이 정의된 라이브러리를 별도로
//다운로드 받아야 한다.
//이 애노테이션은 자바 확장 라이브러리에 포함되어 있다.
//search.maven.org에서 'javax.annotation'으로 검색한다.
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex08/i/application-context.xml");

    // Spring IoC 컨테이너에 들어 있는 객체 출력
    SpringUtils.printBeanList(iocContainer);

    // Car 객체를 꺼내 Engine 객체가 주입되었는지 확인해보자!
    System.out.println(iocContainer.getBean("c1"));
  }
}
------------------------------------------------
실행결과 & 설정파일    
------------------------------------------------
빈 개수: 8
org.springframework.context.annotation.internalConfigurationAnnotationProcessor = org.springframework.context.annotation.ConfigurationClassPostProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor = org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor = org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
org.springframework.context.event.internalEventListenerProcessor = org.springframework.context.event.EventListenerMethodProcessor
org.springframework.context.event.internalEventListenerFactory = org.springframework.context.event.DefaultEventListenerFactory
c1 = com.eomcs.spring.ioc.ex08.i.Car
e1 = com.eomcs.spring.ioc.ex08.i.Engine
e2 = com.eomcs.spring.ioc.ex08.h.Engine
--------------------------------
Car [model=티코, maker=비트자동차, cc=890, auto=true, createdDate=null, engine=Engine [maker=비트자동차, valve=16, cylinder=4]]

//이 태그 하나로 여러 애노테이션을 다룰 객체들을 자동 등록할 수 있다.    
<context:annotation-config/>
------------------------------------------------------------------
//이 애노테이션은 스프링 프레임워크가 아닌 자바에서 제공한다.
//자바 기본 라이브러리에 포함되어 있지 않다.
//따로 라이브러리를 다운로드 받아 포함시켜야 한다.
//@Resource 태그 하나로 @Autowired , @Qulifier를 한번에 처리한다
  @Resource(name = "e1")
  private Engine engine;
------------------------------------------------------------------    
    <bean id="c1" class="com.eomcs.spring.ioc.ex08.i.Car">
        <property name="model" value="티코"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="auto" value="true"/>
    </bean>
    
    <bean id="e1" class="com.eomcs.spring.ioc.ex08.i.Engine">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>
    
    <bean id="e2" class="com.eomcs.spring.ioc.ex08.h.Engine">
        <property name="maker" value="비트자동차"/>
        <property name="valve" value="16"/>
        <property name="cylinder" value="4"/>
    </bean>    
        
// 결론 : @Autowired + @Qualifier = @Resource        
```

라이브러리 추가하기
search.maven.org 에서 'javax.annotation'으로 검색
 1.3.2 이상의 버전 사용

---





ex08까지 

ex08예제 공부할때 Resource 애노테이션이 들어있는 API 사용하기(build.gradle 편집)

- javax.annotation 으로 검색 1.3.2이상 버전 사용

