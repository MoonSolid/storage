인스턴스를 만드려는데 private나 protected 로 막혀있어서 

new 로 만들지 못하면 

인스턴스 생성과정이 복잡하니 메서드로 따로 만들어져있는것으로 이해

factory method  라고 한다

```
getInstance();
```





레퍼런스가 하위 클래스의 인스턴스를 가리킬 때, 레퍼런스를 통해 호출하는 메서드가

하위 클래스에서 오버라이딩 한 것이라면 그 오버라이딩 한 메서드를 호출한다.

그렇다고 해서 하위 클래스에서 추가한 메서드를 호출할 수는 없다

즉 레퍼런스의 클래스에 벗어나서 사용할 수는 없다. 컴파일러가 허락하지 않는다



물론 레퍼런스가 하위클래스의 객체를 가리키기 때문에 하위 클래스로 형변환을 수행한 후에는

하위클래스의 멤버를 사용할 수 있다. 

- 오버라이딩한 객체는 허용하지만 추가된 객체는 허용하지 않는다.



---

비트 연산

int 값에 대한 비트 이동은 0 ~ 31 이다.

long 값에 대한 비트 이동은 0 ~ 63 이다.

비트 이동 유효 범위를 벗어난다면

int 데이터인 경우 비트 이동 값은 하위 5비트만 유효하다.

long 데이터인 경우 비트 이동 값은 하위 6비트만 유효하다.

공식

 n << 5   

만약 n 이 int 타입이라면  s & 0b11111 = 비트 이동 

만약 n 이 long 타입이라면 s & 0b111111 = 비트 이동



어떤 값에 대해 2로 나눈 나머지 값을 구하고 싶다면,

그 값의 하위 1비트 값만 추출하면 된다.

어 떤값에 대해 4로 나눈 나머지 값을 구하고 싶다면,

그 값의 하위 2비트 값만 추출하면 된다.



&연산자를 이용하여 짝수/홀수 알아내기

```
System.out.println((57 & 0x1) == 0 ? "짝수" : "홀수");
```

---

추상 클래스

---

##### 추상 메서드

abstract 

서브클래스에게 공통 기능을 상속해주는 목적으로 만든 클래스이다.

직접 사용하지 않는 클래스이다.

즉 개발자에게 이 클래스를 상속 받아새 클래스를 만들어 쓰라는 의미다.

서브클래스에서 무조건 재정의되어야 하는 메서드인 경우

수퍼 클래스에서 정의하지 않도록 하는 문법이 추상메서드 이다

추상 메서드를 상속 받는 서브클래스는 반드시 "구현"해야 한다.

만약 구현하지 않으면 서브클래스도 추상클래스가 되어야 한다.

왜냐하면 추상 메서드가 있다는 것을 해당 메서드를 실행할 수 없다는 것이고

실행할 수 없는 메서드는 갖는 클래스는 인스턴스를 생성해서는 안되기 때문에

추상 메서드를 갖는 클래스는 반드시 추상클래스여야 한다. 

일반 클래스는 추상메서드를 가질 수 없다.

---

문자열 리터럴은 내부적으로 new String()을 실행한다.

다만 인스턴스를 Heap 이 아닌 String 상수풀에 생성한다.

내용물이 같으면 기존 인스턴스의 주소를 리턴한다.

즉 메모리 절약을 위해 중복 데이터를 갖는 인스턴스를 생성하지 않는다.

JVM이 끝날 때까지 메모리에 유지된다.



Heap 메모리 영역에 저장

```
String s1 = new String("Hello");
String s2 = new String("Hello");
```

- 내용물의 동일 여부를 검사하지 않고 무조건 인스턴스생성





##### 상수풀(string constant pool)

```
String x1 = "Hello";
String x2 = "Hello";
```



x1는 문자열을 담는 변수가 아닌 String 인스턴스의 주소를 리턴한다

x2는 기존의 String 인스턴스의 주소를 리턴한다

x1 과 x2는 같은 인스턴스 주소를 가진다

